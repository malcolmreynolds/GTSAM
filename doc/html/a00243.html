<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>gtsam: gtsam Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gtsam
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
   <div id="projectbrief">gtsam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00243.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gtsam Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Global functions in a separate testing namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00465"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00465.html">noiseModel</a></td></tr>
<tr class="memdesc:a00465"><td class="mdescLeft">&#160;</td><td class="mdescRight">All noise models live in the <a class="el" href="a00465.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">VerticalBlockView</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">SymmetricBlockView</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">DerivedValue</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">DSFVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">FastList</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">FastMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">FastSet</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">FastSetTestableHelper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">FastSetTestableHelper&lt; VALUE, typename boost::enable_if&lt; has_print&lt; VALUE &gt; &gt;::type &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">FastVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">GroupConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concept check enforces a Group structure on a variable type, in which we require the existence of basic algebraic operations.  <a href="a00094.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">LieConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept check class for Lie group type.  <a href="a00122.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">LieMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00125.html" title="LieVector is a wrapper around vector to allow it to be a Lie type.">LieVector</a> is a wrapper around vector to allow it to be a Lie type.  <a href="a00123.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">LieScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00124.html" title="LieScalar is a wrapper around double to allow it to be a Lie type.">LieScalar</a> is a wrapper around double to allow it to be a Lie type.  <a href="a00124.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">LieVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00125.html" title="LieVector is a wrapper around vector to allow it to be a Lie type.">LieVector</a> is a wrapper around vector to allow it to be a Lie type.  <a href="a00125.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">ManifoldConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept check class for Manifold types Requires a mapping between a linear tangent space and the underlying manifold, of which Lie is a specialization.  <a href="a00127.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">G_x1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that computes the derivative of f w.r.t.  <a href="a00074.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">TestableConcept</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">equals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to create a binary predicate.  <a href="a00060.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">equals_star</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary predicate on shared pointers.  <a href="a00061.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">const_selector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that uses templates to select between two types based on whether TEST_TYPE is const or not.  <a href="a00035.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">const_selector&lt; BASIC_TYPE, BASIC_TYPE, AS_NON_CONST, AS_CONST &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the non-const version.  <a href="a00036.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">const_selector&lt; const BASIC_TYPE, BASIC_TYPE, AS_NON_CONST, AS_CONST &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the const version.  <a href="a00037.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">ValueWithDefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct that encapsulates a value with a default, this is just used as a member object so you don't have to specify defaults in the class constructor.  <a href="a00206.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface class for any value that may be used as a variable assignment in a factor graph, and which you must derive to create new variable types to use with gtsam.  <a href="a00200.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">Cal3_S2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">Cal3_S2Stereo</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">Cal3Bundler</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">Cal3DS2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">CheiralityException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">CalibratedCamera</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html">PoseConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose Concept A must contain a translation and a rotation, with each structure accessable directly and a type provided for each.  <a href="a00161.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">RangeMeasurementConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range measurement concept Given a pair of Lie variables, there must exist a function to calculate range with derivatives.  <a href="a00168.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">PinholeCamera</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">Point2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">Point3</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">Pose2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00160.html">Pose3</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">Rot2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">Rot3</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">StereoCheiralityException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">StereoCamera</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">StereoPoint2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">BayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="a00009.html" title="A BayesNet is a list of conditionals, stored in elimination order, i.e.">BayesNet</a> is a list of conditionals, stored in elimination order, i.e.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">BayesTree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">BayesTreeClique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Clique in the tree is an incomplete Bayes net: the variables in the Bayes net are the frontal nodes, and the variables conditioned on are the separator.  <a href="a00011.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">BayesTreeCliqueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for <a class="el" href="a00010.html">BayesTree</a> cliques.  <a href="a00012.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">ClusterTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cluster-tree is associated with a factor graph and is defined as in Koller-Friedman: each node k represents a subset \( C_k \sub X \), and the tree is family preserving, in that each factor \( f_i \) is associated with a single cluster and \( scope(f_i) \sub C_k \).  <a href="a00031.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">Conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for conditional densities, templated on KEY type.  <a href="a00033.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">EliminationTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An elimination tree is a data structure used intermediately during elimination.  <a href="a00059.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">DisconnectedGraphException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when attempting to eliminate a disconnected factor graph, which is not currently possible in gtsam.  <a href="a00046.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">Factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all factor types.  <a href="a00064.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">FactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factor graph is a bipartite graph with factor nodes connected to variable nodes.  <a href="a00065.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">GenericMultifrontalSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Generic Multifrontal Solver class.  <a href="a00089.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">GenericSequentialSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This solver implements sequential variable elimination for factor graphs.  <a href="a00091.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">ordering_key_visitor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">compose_key_visitor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">SDGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00178.html" title="SDGraph is undirected graph with variable keys and double edge weights.">SDGraph</a> is undirected graph with variable keys and double edge weights.  <a href="a00178.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">SGraph</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">PredecessorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from variable key to parent key.  <a href="a00165.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">IndexConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00098.html" title="IndexConditional serves two purposes.">IndexConditional</a> serves two purposes.  <a href="a00098.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">IndexFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00099.html" title="IndexFactor serves two purposes.">IndexFactor</a> serves two purposes.  <a href="a00099.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">ISAM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree with an update methods that implements the iSAM algorithm.  <a href="a00101.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">JunctionTree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">Permutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A permutation reorders variables, for example to reduce fill-in during elimination.  <a href="a00155.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">SymbolicFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic <a class="el" href="a00099.html" title="IndexFactor serves two purposes.">IndexFactor</a> Graph.  <a href="a00190.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">SymbolicMultifrontalSolver</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">SymbolicSequentialSolver</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">VariableIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00207.html" title="The VariableIndex class computes and stores the block column structure of a factor graph...">VariableIndex</a> class computes and stores the block column structure of a factor graph.  <a href="a00207.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">VariableSlots</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combined factor is assembled as one block of rows for each component factor.  <a href="a00208.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">AlgebraicDecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Decision Trees fix the range to double Just has some nice constructors and some syntactic sugar TODO: consider eliminating this class altogether?  <a href="a00003.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An assignment from labels to value index (size_t).  <a href="a00005.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">DecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Decision Trees L = label for variables Y = function range (any algebra), e.g., bool, int, double.  <a href="a00041.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">DecisionTreeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A discrete probabilistic factor.  <a href="a00042.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">DiscreteConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete <a class="el" href="a00033.html" title="Base class for conditional densities, templated on KEY type.">Conditional</a> Density Derives from <a class="el" href="a00042.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a00047.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">DiscreteFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for discrete probabilistic factors The most general one is the derived <a class="el" href="a00042.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a00048.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">DiscreteFactorGraph</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">DiscreteKeys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00050.html" title="DiscreteKeys is a set of keys that can be assembled using the &amp; operator.">DiscreteKeys</a> is a set of keys that can be assembled using the &amp; operator.  <a href="a00050.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">DiscreteMarginals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing marginals of variables in a <a class="el" href="a00049.html">DiscreteFactorGraph</a>.  <a href="a00051.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">DiscreteSequentialSolver</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">Potentials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for both <a class="el" href="a00048.html" title="Base class for discrete probabilistic factors The most general one is the derived DecisionTreeFactor...">DiscreteFactor</a> and <a class="el" href="a00047.html" title="Discrete Conditional Density Derives from DecisionTreeFactor.">DiscreteConditional</a>.  <a href="a00164.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">Signature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> for a discrete conditional density, used to construct conditionals.  <a href="a00180.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">ConjugateGradientParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for the conjugate gradient method  <a href="a00034.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">Errors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of errors  <a href="a00062.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">GaussianConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conditional Gaussian functions as the node in a Bayes network It has a set of parents y,z, etc.  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">GaussianDensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian density.  <a href="a00077.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">GaussianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract virtual base class for <a class="el" href="a00112.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> and <a class="el" href="a00095.html" title="A Gaussian factor using the canonical parameters (information form)">HessianFactor</a>.  <a href="a00078.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">GaussianFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Linear <a class="el" href="a00064.html" title="This is the base class for all factor types.">Factor</a> Graph is a factor graph where all factors are Gaussian, i.e.  <a href="a00079.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">GaussianISAM</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">GaussianJunctionTree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">GaussianMultifrontalSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This solver uses multifrontal elimination to solve a <a class="el" href="a00079.html" title="A Linear Factor Graph is a factor graph where all factors are Gaussian, i.e.">GaussianFactorGraph</a>, i.e.  <a href="a00082.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">GaussianSequentialSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This solver uses sequential variable elimination to solve a <a class="el" href="a00079.html" title="A Linear Factor Graph is a factor graph where all factors are Gaussian, i.e.">GaussianFactorGraph</a>, i.e.  <a href="a00083.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">SlotEntry</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">Scatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">HessianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian factor using the canonical parameters (information form)  <a href="a00095.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">CGState</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">System</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrices.  <a href="a00194.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">IterativeOptimizationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for iterative linear solvers  <a href="a00110.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">IterativeSolver</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">JacobianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian factor in the squared-error form.  <a href="a00112.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman Filter class.  <a href="a00115.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">IndeterminantLinearSystemException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a linear system is ill-posed.  <a href="a00097.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling structure that keeps internal random number generators for diagonal distributions specified by NoiseModel.  <a href="a00176.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">SubgraphPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subgraph conditioner class, as explained in the RSS 2010 submission.  <a href="a00185.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">SubgraphSolverParameters</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">SubgraphSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the SPCG solver presented in Dellaert et al in IROS'10.  <a href="a00186.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">VectorValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of vector-valued variables associated each with a unique integer index.  <a href="a00210.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">DoglegParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Levenberg-Marquardt optimization.  <a href="a00055.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">DoglegState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for <a class="el" href="a00053.html" title="This class performs Dogleg nonlinear optimization.">DoglegOptimizer</a>.  <a href="a00056.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">DoglegOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Dogleg nonlinear optimization.  <a href="a00053.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">DoglegOptimizerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the implementation of the Dogleg algorithm.  <a href="a00054.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">ExtendedKalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a generic Extended Kalman Filter class implemented using nonlinear factors.  <a href="a00063.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">GaussNewtonParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Gauss-Newton optimization, inherits from NonlinearOptimizationParams.  <a href="a00085.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">GaussNewtonState</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">GaussNewtonOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Gauss-Newton nonlinear optimization.  <a href="a00084.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">ISAM2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">ISAM2GaussNewtonParams</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">ISAM2DoglegParams</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">ISAM2Params</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">ISAM2Result</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">ISAM2Clique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized Clique structure for <a class="el" href="a00102.html">ISAM2</a>, incorporating caching and gradient contribution TODO: more documentation.  <a href="a00103.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">LabeledSymbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized version of <a class="el" href="a00189.html" title="Character and index key used in VectorValues, GaussianFactorGraph, GaussianFactor, etc.">gtsam::Symbol</a> for multi-robot use.  <a href="a00117.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">LevenbergMarquardtParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Levenberg-Marquardt optimization.  <a href="a00120.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">LevenbergMarquardtState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for <a class="el" href="a00119.html" title="This class performs Levenberg-Marquardt nonlinear optimization.">LevenbergMarquardtOptimizer</a>.  <a href="a00121.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">LevenbergMarquardtOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Levenberg-Marquardt nonlinear optimization.  <a href="a00119.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">LinearContainerFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy version of a generic linear factor to be injected into a nonlinear factor graph.  <a href="a00126.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">Marginals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing Gaussian marginals of variables in a <a class="el" href="a00145.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a>.  <a href="a00129.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">JointMarginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to store and access a joint marginal, returned from <a class="el" href="a00129.html#a72725b4ec9f8730618ddfbcdd0ba52d8" title="Compute the joint marginal covariance of several variables.">Marginals::jointMarginalCovariance</a> and <a class="el" href="a00129.html#aff9594cec09117bdb69214a3924f9569" title="Compute the joint marginal information of several variables.">Marginals::jointMarginalInformation</a>.  <a href="a00113.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">NonlinearConjugateGradientState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the nonlinear cg method using the template below.  <a href="a00140.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">NonlinearConjugateGradientOptimizer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">NonlinearEquality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equality factor that forces either one variable to a constant, or a set of variables to be equal to each other.  <a href="a00141.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">NonlinearEquality1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple unary equality constraint - fixes a value for a variable.  <a href="a00142.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">NonlinearEquality2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple binary equality constraint - this constraint forces two factors to be the same.  <a href="a00143.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">MarginalizeNonleafException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when requesting to marginalize out variables from <a class="el" href="a00102.html">ISAM2</a> that are not leaves.  <a href="a00128.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">NonlinearFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear factor base class.  <a href="a00144.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">NoiseModelFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density \( P(z|x) \propto exp -0.5*|z-h(x)|^2_C \) Templated on the parameter type X and the values structure <a class="el" href="a00202.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> There is no return type specified for h(x).  <a href="a00132.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">NoiseModelFactor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00132.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 1 variable.  <a href="a00133.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">NoiseModelFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00132.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 2 variables.  <a href="a00134.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">NoiseModelFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00132.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 3 variables.  <a href="a00135.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">NoiseModelFactor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00132.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 4 variables.  <a href="a00136.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">NoiseModelFactor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00132.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 5 variables.  <a href="a00137.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">NoiseModelFactor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00132.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 6 variables.  <a href="a00138.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">GraphvizFormatting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting options when saving in GraphViz format using <a class="el" href="a00145.html#af4fe6c4a779bbc8b985ffdb6b55c3227" title="Write the graph in GraphViz format for visualization.">NonlinearFactorGraph::saveGraph</a>.  <a href="a00093.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00145.html">NonlinearFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-linear factor graph is a graph of non-Gaussian, i.e.  <a href="a00145.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">NonlinearISAM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to manage <a class="el" href="a00101.html" title="A Bayes tree with an update methods that implements the iSAM algorithm.">ISAM</a> in a nonlinear context.  <a href="a00146.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">NonlinearOptimizerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The common parameters for Nonlinear optimizers.  <a href="a00148.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">NonlinearOptimizerState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a nonlinear optimization state, including the current estimate of the variable values, error, and number of iterations.  <a href="a00149.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">NonlinearOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the abstract interface for classes that can optimize for the maximum-likelihood estimate of a <a class="el" href="a00145.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a>.  <a href="a00147.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">Ordering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ordering is a map from symbols (non-typed keys) to integer indices.  <a href="a00151.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">Unordered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a set of unordered indices  <a href="a00199.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">OrderingIndexFormatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">MultiRobotLinearFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of orderingIndexFormatter using multi-robot formatter.  <a href="a00130.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">SuccessiveLinearizationParams</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character and index key used in <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a>, <a class="el" href="a00079.html" title="A Linear Factor Graph is a factor graph where all factors are Gaussian, i.e.">GaussianFactorGraph</a>, <a class="el" href="a00078.html" title="An abstract virtual base class for JacobianFactor and HessianFactor.">GaussianFactor</a>, etc.  <a href="a00189.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">ValueCloneAllocator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">_ValuesKeyValuePair</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html">_ValuesConstKeyValuePair</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">Values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-templated config holding any types of Manifold-group elements.  <a href="a00202.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">ValuesKeyAlreadyExists</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">ValuesKeyDoesNotExist</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">ValuesIncorrectType</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">DynamicValuesMismatched</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">WhiteNoiseFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor to estimate parameters of zero-mean Gaussian white noise.  <a href="a00212.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">AntiFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">BearingFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">BearingRangeFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">BetweenFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">BetweenConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary between constraint - forces between to a given value This constraint requires the underlying type to a Lie type.  <a href="a00015.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">BoundingConstraint1</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">BoundingConstraint2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary scalar inequality constraint, with a similar <a class="el" href="a00018.html#ad1415ee808cefd215e6410c6dd9f4f51" title="function producing a scalar value to compare to the threshold Must have optional argument for derivat...">value()</a> function to implement for specific systems.  <a href="a00018.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">GeneralSFMFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">GeneralSFMFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-linear factor for a constraint derived from a 2D measurement.  <a href="a00088.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">PoseRotationPrior</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">PoseTranslationPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prior on the translation part of a pose.  <a href="a00163.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html">PriorFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">GenericProjectionFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">RangeFactor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">ReferenceFrameFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint between two landmarks in separate maps Templated on: Point : Type of landmark Transform : Transform variable class.  <a href="a00170.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">GenericStereoFactor</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a03a792d93b6d3283b4c2f3fb5954190f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a792d93b6d3283b4c2f3fb5954190f"></a>
typedef Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b></td></tr>
<tr class="memitem:ae14bcd25aa57e5e0477389b9a08b9098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae14bcd25aa57e5e0477389b9a08b9098"></a>
typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic, <br class="typebreak"/>
Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixRowMajor</b></td></tr>
<tr class="memitem:a384af2a352b80410963045e4aefd2022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384af2a352b80410963045e4aefd2022"></a>
typedef Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix3</b></td></tr>
<tr class="memitem:a476d1a6dc0b0dd54614c98c0e00decfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a476d1a6dc0b0dd54614c98c0e00decfa"></a>
typedef Eigen::Matrix4d&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix4</b></td></tr>
<tr class="memitem:a3b70291bcbb7bca8c0e4a2e8c45954c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b70291bcbb7bca8c0e4a2e8c45954c3"></a>
typedef Eigen::Matrix&lt; double, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix6</b></td></tr>
<tr class="memitem:a3218833aef585dcaf060bdef7c8ee861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3218833aef585dcaf060bdef7c8ee861"></a>
typedef Eigen::Block&lt; Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubMatrix</b></td></tr>
<tr class="memitem:a7197dd6ad1eee8ece9aa15edbabc3b68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7197dd6ad1eee8ece9aa15edbabc3b68"></a>
typedef Eigen::Block&lt; const <br class="typebreak"/>
Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSubMatrix</b></td></tr>
<tr class="memitem:ab6d32a7175826a8984dc554fa0025a49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d32a7175826a8984dc554fa0025a49"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a></td></tr>
<tr class="memdesc:ab6d32a7175826a8984dc554fa0025a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer variable index type. <br/></td></tr>
<tr class="memitem:acd76f1ddc9222a483adcca0335556277"><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; std::string(<a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#acd76f1ddc9222a483adcca0335556277">IndexFormatter</a></td></tr>
<tr class="memdesc:acd76f1ddc9222a483adcca0335556277"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to convert indices to strings, for example by translating back to a nonlinear key and then to a <a class="el" href="a00189.html" title="Character and index key used in VectorValues, GaussianFactorGraph, GaussianFactor, etc.">Symbol</a>.  <a href="#acd76f1ddc9222a483adcca0335556277"></a><br/></td></tr>
<tr class="memitem:aad6a39f5eb77f4d28961cef67ebf98f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad6a39f5eb77f4d28961cef67ebf98f3"></a>
typedef Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>
<tr class="memitem:a54f77c4fccbc506166116e363c1fa06e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f77c4fccbc506166116e363c1fa06e"></a>
typedef Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><b>Vector2</b></td></tr>
<tr class="memitem:a87074ffb029b86bb8c54edd2a29cb1ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87074ffb029b86bb8c54edd2a29cb1ae"></a>
typedef Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>Vector3</b></td></tr>
<tr class="memitem:a504170338a608d956ffa625dc6375b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a504170338a608d956ffa625dc6375b37"></a>
typedef Eigen::Matrix&lt; double, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector6</b></td></tr>
<tr class="memitem:ae8d1471ff74798e876eac3c5dddc3d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8d1471ff74798e876eac3c5dddc3d53"></a>
typedef Eigen::VectorBlock<br class="typebreak"/>
&lt; Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubVector</b></td></tr>
<tr class="memitem:aab75d3757735f345508c14966678e983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab75d3757735f345508c14966678e983"></a>
typedef Eigen::VectorBlock<br class="typebreak"/>
&lt; const Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSubVector</b></td></tr>
<tr class="memitem:af15dec8cc8bf0a43bc649709b84cf771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15dec8cc8bf0a43bc649709b84cf771"></a>
typedef std::pair&lt; <a class="el" href="a00157.html">Point2</a>, <a class="el" href="a00157.html">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af15dec8cc8bf0a43bc649709b84cf771">Point2Pair</a></td></tr>
<tr class="memdesc:af15dec8cc8bf0a43bc649709b84cf771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pose between a vector of 2D point correspondences (p,q) where q = Pose2::transform_from(p) = t + R*p. <br/></td></tr>
<tr class="memitem:a450a25bc3b2e869f58054168b1262213"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a450a25bc3b2e869f58054168b1262213"></a>
typedef std::pair&lt; <a class="el" href="a00158.html">Point3</a>, <a class="el" href="a00158.html">Point3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a450a25bc3b2e869f58054168b1262213">Point3Pair</a></td></tr>
<tr class="memdesc:a450a25bc3b2e869f58054168b1262213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pose between a vector of 3D point correspondences (p,q) where q = Pose3::transform_from(p) = t + R*p. <br/></td></tr>
<tr class="memitem:a59e2c1120d40da6062c03ab31e869065"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Quaternion<br class="typebreak"/>
&lt; double, Eigen::DontAlign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a59e2c1120d40da6062c03ab31e869065">Quaternion</a></td></tr>
<tr class="memdesc:a59e2c1120d40da6062c03ab31e869065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to an Eigen Quaternion&lt;double&gt;, we disable alignment because geometry objects are stored in boost pool allocators, in <a class="el" href="a00202.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> containers, and and these pool allocators do not support alignment.  <a href="#a59e2c1120d40da6062c03ab31e869065"></a><br/></td></tr>
<tr class="memitem:a7bb03eb3dceb63b0933c94c15b83cb39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bb03eb3dceb63b0933c94c15b83cb39"></a>
typedef <a class="el" href="a00156.html">PinholeCamera</a>&lt; <a class="el" href="a00019.html">Cal3_S2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7bb03eb3dceb63b0933c94c15b83cb39">SimpleCamera</a></td></tr>
<tr class="memdesc:a7bb03eb3dceb63b0933c94c15b83cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple camera class with a <a class="el" href="a00019.html">Cal3_S2</a> calibration. <br/></td></tr>
<tr class="memitem:a25a4acc23b55b829f094a9d311ad333c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a4acc23b55b829f094a9d311ad333c"></a>
typedef <a class="el" href="a00059.html">EliminationTree</a><br class="typebreak"/>
&lt; <a class="el" href="a00099.html">IndexFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SymbolicEliminationTree</b></td></tr>
<tr class="memitem:acc6e938cb7de2caa3597ed492efe6b85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc6e938cb7de2caa3597ed492efe6b85"></a>
typedef <a class="el" href="a00009.html">BayesNet</a><br class="typebreak"/>
&lt; <a class="el" href="a00098.html">IndexConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SymbolicBayesNet</b></td></tr>
<tr class="memitem:a6bbc386b6c9f0483c93a7e20ef1c4825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bbc386b6c9f0483c93a7e20ef1c4825"></a>
typedef <a class="el" href="a00010.html">BayesTree</a><br class="typebreak"/>
&lt; <a class="el" href="a00098.html">IndexConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SymbolicBayesTree</b></td></tr>
<tr class="memitem:a91d60d288588d255557556dfaa3a6d50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d60d288588d255557556dfaa3a6d50"></a>
typedef <a class="el" href="a00009.html">BayesNet</a><br class="typebreak"/>
&lt; <a class="el" href="a00047.html">DiscreteConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DiscreteBayesNet</b></td></tr>
<tr class="memitem:a4ee698b6d04431828d60c6c112926876"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ee698b6d04431828d60c6c112926876"></a>
typedef std::pair&lt; <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a></td></tr>
<tr class="memdesc:a4ee698b6d04431828d60c6c112926876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type for discrete conditionals Includes name and cardinality. <br/></td></tr>
<tr class="memitem:a10d4ade73a7e1d467c65d858dff18016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10d4ade73a7e1d467c65d858dff18016"></a>
typedef <a class="el" href="a00009.html">BayesNet</a><br class="typebreak"/>
&lt; <a class="el" href="a00076.html">GaussianConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a></td></tr>
<tr class="memdesc:a10d4ade73a7e1d467c65d858dff18016"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes net made from linear-Gaussian densities. <br/></td></tr>
<tr class="memitem:ab6e5a4884342656e0837ef07008ec03f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
noiseModel::Base::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a></td></tr>
<tr class="memdesc:ab6e5a4884342656e0837ef07008ec03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note, deliberately not in <a class="el" href="a00465.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace.  <a href="#ab6e5a4884342656e0837ef07008ec03f"></a><br/></td></tr>
<tr class="memitem:a78bc6f977e83dce647b2c006ea3dca5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bc6f977e83dce647b2c006ea3dca5f"></a>
typedef <br class="typebreak"/>
noiseModel::Gaussian::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedGaussian</b></td></tr>
<tr class="memitem:a413190e269d694931cd6c69fafa7985a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a413190e269d694931cd6c69fafa7985a"></a>
typedef <br class="typebreak"/>
noiseModel::Diagonal::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedDiagonal</b></td></tr>
<tr class="memitem:a663b232e794d75dc8eb4239f12cd2506"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663b232e794d75dc8eb4239f12cd2506"></a>
typedef <a class="el" href="a00068.html">FastMap</a>&lt; char, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ISAM2ThresholdMap</b></td></tr>
<tr class="memitem:a1b8707b19ab1e617a8f20c6d68b6d310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b8707b19ab1e617a8f20c6d68b6d310"></a>
typedef <br class="typebreak"/>
ISAM2ThresholdMap::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>ISAM2ThresholdMapValue</b></td></tr>
<tr class="memitem:aa365a1bd3614e767adbd35f44ba4fec3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa365a1bd3614e767adbd35f44ba4fec3"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a></td></tr>
<tr class="memdesc:aa365a1bd3614e767adbd35f44ba4fec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer nonlinear key type. <br/></td></tr>
<tr class="memitem:a29dee574fe60f586d71b2c0d957dc8bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29dee574fe60f586d71b2c0d957dc8bb"></a>
typedef boost::function<br class="typebreak"/>
&lt; std::string(<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a></td></tr>
<tr class="memdesc:a29dee574fe60f586d71b2c0d957dc8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a function to format a key, i.e. to convert it to a string. <br/></td></tr>
<tr class="memitem:a6fcb28bfc2908ca506aa5503f24b4c8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fcb28bfc2908ca506aa5503f24b4c8f"></a>
typedef <a class="el" href="a00067.html">FastList</a>&lt; <a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a6fcb28bfc2908ca506aa5503f24b4c8f">KeyList</a></td></tr>
<tr class="memdesc:a6fcb28bfc2908ca506aa5503f24b4c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful typedefs for operations with <a class="el" href="a00202.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> - allow for matlab interfaces. <br/></td></tr>
<tr class="memitem:a18932dfd5dba41c0574e6db16cdb5932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18932dfd5dba41c0574e6db16cdb5932"></a>
typedef <a class="el" href="a00072.html">FastVector</a>&lt; <a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeyVector</b></td></tr>
<tr class="memitem:aea882e1ed30f89066e79a37dc5aa7b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea882e1ed30f89066e79a37dc5aa7b54"></a>
typedef <a class="el" href="a00069.html">FastSet</a>&lt; <a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySet</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a166d6cd0600305853a0d3aebad70a45a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45a">SummarizationMode</a> { <b>PARTIAL_QR</b> =  0, 
<a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45aacf119d9acb3827e7ee3eea1be23f3a82">PARTIAL_CHOLESKY</a> =  1, 
<a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45aa82cb5313411a3fe8ce502eff83ebda06">SEQUENTIAL_QR</a> =  2, 
<a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45aae002bd076d926799d388fe13e6c05d76">SEQUENTIAL_CHOLESKY</a> =  3
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a747683f736c50bca16b3aab0e95b1b76"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a747683f736c50bca16b3aab0e95b1b76">choleskyCareful</a> (Matrix &amp;ATA, int order=-1)</td></tr>
<tr class="memdesc:a747683f736c50bca16b3aab0e95b1b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Careful" Cholesky computes the positive square-root of a positive symmetric semi-definite matrix (i.e.  <a href="#a747683f736c50bca16b3aab0e95b1b76"></a><br/></td></tr>
<tr class="memitem:a1eb8c69f6e0b90ac2dec4287ee8fcb0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a1eb8c69f6e0b90ac2dec4287ee8fcb0a">choleskyPartial</a> (Matrix &amp;ABC, size_t nFrontal)</td></tr>
<tr class="memdesc:a1eb8c69f6e0b90ac2dec4287ee8fcb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial Cholesky computes a factor [R S such that [R' 0 [R S = [A B 0 L] S' I] 0 L] B' C].  <a href="#a1eb8c69f6e0b90ac2dec4287ee8fcb0a"></a><br/></td></tr>
<tr class="memitem:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a473aea76af7b0cbec8f26e6abf1ed87e">between_default</a> (const T &amp;l1, const T &amp;l2)</td></tr>
<tr class="memdesc:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These core global functions can be specialized by new Lie types for better performance.  <a href="#a473aea76af7b0cbec8f26e6abf1ed87e"></a><br/></td></tr>
<tr class="memitem:a75c80ae2fd169fcdd8708c37784a880a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a75c80ae2fd169fcdd8708c37784a880a"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a75c80ae2fd169fcdd8708c37784a880a">logmap_default</a> (const T &amp;l0, const T &amp;lp)</td></tr>
<tr class="memdesc:a75c80ae2fd169fcdd8708c37784a880a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log map centered at l0, s.t.  <a href="#a75c80ae2fd169fcdd8708c37784a880a"></a><br/></td></tr>
<tr class="memitem:af0170df6a1f64df845e4445bdf777742"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af0170df6a1f64df845e4445bdf777742"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#af0170df6a1f64df845e4445bdf777742">expmap_default</a> (const T &amp;t, const Vector &amp;d)</td></tr>
<tr class="memdesc:af0170df6a1f64df845e4445bdf777742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential map centered at l0, s.t.  <a href="#af0170df6a1f64df845e4445bdf777742"></a><br/></td></tr>
<tr class="memitem:adbd55c711e6ceee791b595558eb3ec8a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbd55c711e6ceee791b595558eb3ec8a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#adbd55c711e6ceee791b595558eb3ec8a">BCH</a> (const T &amp;X, const T &amp;Y)</td></tr>
<tr class="memdesc:adbd55c711e6ceee791b595558eb3ec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three term approximation of the Baker�Campbell�Hausdorff formula In non-commutative Lie groups, when composing exp(Z) = exp(X)exp(Y) it is not true that Z = X+Y.  <a href="#adbd55c711e6ceee791b595558eb3ec8a"></a><br/></td></tr>
<tr class="memitem:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe28b7f8e3592fb9f5cf9ebae09497ba"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#afe28b7f8e3592fb9f5cf9ebae09497ba">wedge</a> (const Vector &amp;x)</td></tr>
<tr class="memdesc:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of wedge (see Murray94book) used to convert from n exponential coordinates to n*n element of the Lie algebra. <br/></td></tr>
<tr class="memitem:a3041816208c79ef76d3ef2e0991d90b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3041816208c79ef76d3ef2e0991d90b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a3041816208c79ef76d3ef2e0991d90b2">expm</a> (const Vector &amp;x, int K=7)</td></tr>
<tr class="memdesc:a3041816208c79ef76d3ef2e0991d90b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential map given exponential coordinates class T needs a wedge&lt;&gt; function and a constructor from Matrix.  <a href="#a3041816208c79ef76d3ef2e0991d90b2"></a><br/></td></tr>
<tr class="memitem:a93c47e8e5ee7d4486b18a82641fedcd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93c47e8e5ee7d4486b18a82641fedcd6"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a93c47e8e5ee7d4486b18a82641fedcd6">Matrix_</a> (size_t m, size_t n, const double *const data)</td></tr>
<tr class="memdesc:a93c47e8e5ee7d4486b18a82641fedcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with size and initial data, row order ! <br/></td></tr>
<tr class="memitem:af8c264a5807fca0a6b311c14ee7a6e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c264a5807fca0a6b311c14ee7a6e9a"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af8c264a5807fca0a6b311c14ee7a6e9a">Matrix_</a> (size_t m, size_t n, const Vector &amp;v)</td></tr>
<tr class="memdesc:af8c264a5807fca0a6b311c14ee7a6e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with size and vector data, column order !!! <br/></td></tr>
<tr class="memitem:a7b7bed77748c622c854ddc1d412e70ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7bed77748c622c854ddc1d412e70ac"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7b7bed77748c622c854ddc1d412e70ac">Matrix_</a> (size_t m, size_t n,...)</td></tr>
<tr class="memdesc:a7b7bed77748c622c854ddc1d412e70ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">nice constructor, dangerous as number of arguments must be exactly right and you have to pass doubles !!! always use 0.0 never 0 <br/></td></tr>
<tr class="memitem:a33240affd7dc54b7a85c6f3136853f7f"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a33240affd7dc54b7a85c6f3136853f7f">zeros</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a33240affd7dc54b7a85c6f3136853f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an zeros matrix, with matlab-like syntax.  <a href="#a33240affd7dc54b7a85c6f3136853f7f"></a><br/></td></tr>
<tr class="memitem:a8da8a8496d1e82788f239de578581424"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8da8a8496d1e82788f239de578581424"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8da8a8496d1e82788f239de578581424">ones</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a8da8a8496d1e82788f239de578581424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ones matrix, with matlab-like syntax. <br/></td></tr>
<tr class="memitem:a728f2e626412c19fa789a65eaba41819"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a728f2e626412c19fa789a65eaba41819">eye</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a728f2e626412c19fa789a65eaba41819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an identity matrix, with matlab-like syntax.  <a href="#a728f2e626412c19fa789a65eaba41819"></a><br/></td></tr>
<tr class="memitem:afcc9d7205e49e222505860d4a302303f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc9d7205e49e222505860d4a302303f"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>diag</b> (const Vector &amp;v)</td></tr>
<tr class="memitem:a3f9622226dfe06908f11b42bf0bdd22d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f9622226dfe06908f11b42bf0bdd22d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3f9622226dfe06908f11b42bf0bdd22d">assert_equal</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a3f9622226dfe06908f11b42bf0bdd22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance, prints out message if unequal <br/></td></tr>
<tr class="memitem:a7a116d0643f123ef3b15d91056506492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a116d0643f123ef3b15d91056506492"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7a116d0643f123ef3b15d91056506492">assert_inequal</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a7a116d0643f123ef3b15d91056506492"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequals with an tolerance, prints out message if within tolerance <br/></td></tr>
<tr class="memitem:abb0e19bbbeaca95843e8161b89a12fda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb0e19bbbeaca95843e8161b89a12fda"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#abb0e19bbbeaca95843e8161b89a12fda">assert_equal</a> (const std::list&lt; Matrix &gt; &amp;As, const std::list&lt; Matrix &gt; &amp;Bs, double tol=1e-9)</td></tr>
<tr class="memdesc:abb0e19bbbeaca95843e8161b89a12fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance, prints out message if unequal <br/></td></tr>
<tr class="memitem:ad8f0349471464c1fb515819d9503849a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8f0349471464c1fb515819d9503849a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad8f0349471464c1fb515819d9503849a">linear_independent</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:ad8f0349471464c1fb515819d9503849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the rows of two matrices are linear independent <br/></td></tr>
<tr class="memitem:a4b81794af72954abafbb726fc712f5db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b81794af72954abafbb726fc712f5db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a4b81794af72954abafbb726fc712f5db">linear_dependent</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a4b81794af72954abafbb726fc712f5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the rows of two matrices are linear dependent <br/></td></tr>
<tr class="memitem:a991da8573b30c717bf609e2ff5d0069b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a991da8573b30c717bf609e2ff5d0069b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a991da8573b30c717bf609e2ff5d0069b">multiplyAdd</a> (double alpha, const Matrix &amp;A, const Vector &amp;x, Vector &amp;e)</td></tr>
<tr class="memdesc:a991da8573b30c717bf609e2ff5d0069b"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style e &lt;- e + alpha*A*x. <br/></td></tr>
<tr class="memitem:ad5119e8b02af1b70c1719b3b79c39769"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5119e8b02af1b70c1719b3b79c39769"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad5119e8b02af1b70c1719b3b79c39769">multiplyAdd</a> (const Matrix &amp;A, const Vector &amp;x, Vector &amp;e)</td></tr>
<tr class="memdesc:ad5119e8b02af1b70c1719b3b79c39769"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style e &lt;- e + A*x. <br/></td></tr>
<tr class="memitem:a2218e53a2b99c449e70aa5b7805895fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2218e53a2b99c449e70aa5b7805895fc"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a2218e53a2b99c449e70aa5b7805895fc">operator^</a> (const Matrix &amp;A, const Vector &amp;v)</td></tr>
<tr class="memdesc:a2218e53a2b99c449e70aa5b7805895fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload ^ for trans(A)*v We transpose the vectors for speed. <br/></td></tr>
<tr class="memitem:a376e4d2e196451babb362c6eb04a7a00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a376e4d2e196451babb362c6eb04a7a00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a376e4d2e196451babb362c6eb04a7a00">transposeMultiplyAdd</a> (double alpha, const Matrix &amp;A, const Vector &amp;e, Vector &amp;x)</td></tr>
<tr class="memdesc:a376e4d2e196451babb362c6eb04a7a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style x &lt;- x + alpha*A'*e. <br/></td></tr>
<tr class="memitem:aa038f2f0c136a5c5ca2dcfcc425e9c28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa038f2f0c136a5c5ca2dcfcc425e9c28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa038f2f0c136a5c5ca2dcfcc425e9c28">transposeMultiplyAdd</a> (const Matrix &amp;A, const Vector &amp;e, Vector &amp;x)</td></tr>
<tr class="memdesc:aa038f2f0c136a5c5ca2dcfcc425e9c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style x &lt;- x + A'*e. <br/></td></tr>
<tr class="memitem:aebbe1dcc822b54420d461efbbebe3141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebbe1dcc822b54420d461efbbebe3141"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aebbe1dcc822b54420d461efbbebe3141">transposeMultiplyAdd</a> (double alpha, const Matrix &amp;A, const Vector &amp;e, SubVector x)</td></tr>
<tr class="memdesc:aebbe1dcc822b54420d461efbbebe3141"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style x &lt;- x + alpha*A'*e. <br/></td></tr>
<tr class="memitem:af3904fab46603b7c1f0f3f86e9a3ae19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3904fab46603b7c1f0f3f86e9a3ae19"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af3904fab46603b7c1f0f3f86e9a3ae19">Vector_</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:af3904fab46603b7c1f0f3f86e9a3ae19"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert to column vector, column order !!! <br/></td></tr>
<tr class="memitem:a93f7913cd214cdc66d7abb39f8264b24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93f7913cd214cdc66d7abb39f8264b24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a93f7913cd214cdc66d7abb39f8264b24">print</a> (const Matrix &amp;A, const std::string &amp;s=&quot;&quot;, std::ostream &amp;stream=std::cout)</td></tr>
<tr class="memdesc:a93f7913cd214cdc66d7abb39f8264b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a matrix <br/></td></tr>
<tr class="memitem:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb7eed9019d3fda8fcf74fbf85b85c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3eb7eed9019d3fda8fcf74fbf85b85c9">save</a> (const Matrix &amp;A, const std::string &amp;s, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a matrix to file, which can be loaded by matlab <br/></td></tr>
<tr class="memitem:a7d85957bab2d18cf56ab9aaf95a106de"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7d85957bab2d18cf56ab9aaf95a106de">operator&gt;&gt;</a> (std::istream &amp;inputStream, Matrix &amp;destinationMatrix)</td></tr>
<tr class="memdesc:a7d85957bab2d18cf56ab9aaf95a106de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from an input stream, such as a file.  <a href="#a7d85957bab2d18cf56ab9aaf95a106de"></a><br/></td></tr>
<tr class="memitem:a7b42c1bd6a8d1152ee1ef86b96526993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7b42c1bd6a8d1152ee1ef86b96526993">insertSub</a> (Matrix &amp;fullMatrix, const Matrix &amp;subMatrix, size_t i, size_t j)</td></tr>
<tr class="memdesc:a7b42c1bd6a8d1152ee1ef86b96526993"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a submatrix IN PLACE at a specified location in a larger matrix NOTE: there is no size checking  <a href="#a7b42c1bd6a8d1152ee1ef86b96526993"></a><br/></td></tr>
<tr class="memitem:af1c32907adce74cf9edd6ee5bba5a085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1c32907adce74cf9edd6ee5bba5a085"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af1c32907adce74cf9edd6ee5bba5a085">diag</a> (const std::vector&lt; Matrix &gt; &amp;Hs)</td></tr>
<tr class="memdesc:af1c32907adce74cf9edd6ee5bba5a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix with submatrices along its diagonal. <br/></td></tr>
<tr class="memitem:ab8583da4b37aefb1697375402a265c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab8583da4b37aefb1697375402a265c9a">insertColumn</a> (Matrix &amp;A, const Vector &amp;col, size_t j)</td></tr>
<tr class="memdesc:ab8583da4b37aefb1697375402a265c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a column into a matrix IN PLACE NOTE: there is no size checking Alternate form allows for vectors smaller than the whole column to be inserted  <a href="#ab8583da4b37aefb1697375402a265c9a"></a><br/></td></tr>
<tr class="memitem:ac748fa850cd803d6caf81af3088d96d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac748fa850cd803d6caf81af3088d96d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertColumn</b> (Matrix &amp;A, const Vector &amp;col, size_t i, size_t j)</td></tr>
<tr class="memitem:ac7bb98c618c787686109e18a71e87463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7bb98c618c787686109e18a71e87463"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>columnNormSquare</b> (const Matrix &amp;A)</td></tr>
<tr class="memitem:a1feaf381266c4fa007188c663aa733fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1feaf381266c4fa007188c663aa733fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a1feaf381266c4fa007188c663aa733fa">solve</a> (Matrix &amp;A, Matrix &amp;B)</td></tr>
<tr class="memdesc:a1feaf381266c4fa007188c663aa733fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve AX=B via in-place Lu factorization and backsubstitution After calling, A contains LU, B the solved RHS vectors <br/></td></tr>
<tr class="memitem:a569422c152fe1a6d49e349cb2ec1aa5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a569422c152fe1a6d49e349cb2ec1aa5e"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a569422c152fe1a6d49e349cb2ec1aa5e">inverse</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a569422c152fe1a6d49e349cb2ec1aa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert A <br/></td></tr>
<tr class="memitem:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="memItemLeft" align="right" valign="top">pair&lt; Matrix, Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ae32c295e2c40c1e85f146a8a6266eaa8">qr</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder QR factorization, Golub &amp; Van Loan p 224, explicit version.  <a href="#ae32c295e2c40c1e85f146a8a6266eaa8"></a><br/></td></tr>
<tr class="memitem:a60019a03f26b92c6b2a08e43d153d4c0"><td class="memItemLeft" align="right" valign="top">list&lt; boost::tuple&lt; Vector, <br class="typebreak"/>
double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a60019a03f26b92c6b2a08e43d153d4c0">weighted_eliminate</a> (Matrix &amp;A, Vector &amp;b, const Vector &amp;sigmas)</td></tr>
<tr class="memdesc:a60019a03f26b92c6b2a08e43d153d4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imperative algorithm for in-place full elimination with weights and constraint handling.  <a href="#a60019a03f26b92c6b2a08e43d153d4c0"></a><br/></td></tr>
<tr class="memitem:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#abdd1ab05e8ac90b340fbd8f3b322dc6d">householder_</a> (Matrix &amp;A, size_t k, bool copy_vectors)</td></tr>
<tr class="memdesc:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imperative version of Householder QR factorization, Golub &amp; Van Loan p 224 version with Householder vectors below diagonal, as in GVL.  <a href="#abdd1ab05e8ac90b340fbd8f3b322dc6d"></a><br/></td></tr>
<tr class="memitem:a7baa2f3184a444adce108633c0265e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7baa2f3184a444adce108633c0265e0c">householder</a> (Matrix &amp;A, size_t k)</td></tr>
<tr class="memdesc:a7baa2f3184a444adce108633c0265e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder tranformation, zeros below diagonal.  <a href="#a7baa2f3184a444adce108633c0265e0c"></a><br/></td></tr>
<tr class="memitem:a0d998e1b770c9864946ddb031b1c4522"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a0d998e1b770c9864946ddb031b1c4522">backSubstituteLower</a> (const Matrix &amp;L, const Vector &amp;b, bool unit=false)</td></tr>
<tr class="memdesc:a0d998e1b770c9864946ddb031b1c4522"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute L*x=b  <a href="#a0d998e1b770c9864946ddb031b1c4522"></a><br/></td></tr>
<tr class="memitem:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a6c4876cbe85d5651a52eda0e97c60f2f">backSubstituteUpper</a> (const Matrix &amp;U, const Vector &amp;b, bool unit=false)</td></tr>
<tr class="memdesc:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute U*x=b  <a href="#a6c4876cbe85d5651a52eda0e97c60f2f"></a><br/></td></tr>
<tr class="memitem:a8b0bf332d52b333dab2b20d763c8925b"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8b0bf332d52b333dab2b20d763c8925b">backSubstituteUpper</a> (const Vector &amp;b, const Matrix &amp;U, bool unit=false)</td></tr>
<tr class="memdesc:a8b0bf332d52b333dab2b20d763c8925b"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute x'*U=b'  <a href="#a8b0bf332d52b333dab2b20d763c8925b"></a><br/></td></tr>
<tr class="memitem:a5c82884a356ddd09229a5283aed04df9"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a5c82884a356ddd09229a5283aed04df9">stack</a> (size_t nrMatrices,...)</td></tr>
<tr class="memdesc:a5c82884a356ddd09229a5283aed04df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix by stacking other matrices Given a set of matrices: A1, A2, A3...  <a href="#a5c82884a356ddd09229a5283aed04df9"></a><br/></td></tr>
<tr class="memitem:a952843d658e0425fda99f14f408760ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952843d658e0425fda99f14f408760ca"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>stack</b> (const std::vector&lt; Matrix &gt; &amp;blocks)</td></tr>
<tr class="memitem:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad8b524ba6c9aed0d21a020999c9b5d88">collect</a> (const std::vector&lt; const Matrix * &gt; &amp;matrices, size_t m=0, size_t n=0)</td></tr>
<tr class="memdesc:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix by concatenating Given a set of matrices: A1, A2, A3...  <a href="#ad8b524ba6c9aed0d21a020999c9b5d88"></a><br/></td></tr>
<tr class="memitem:ac71fc8eaea5f380a91bcfc1e8b140522"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac71fc8eaea5f380a91bcfc1e8b140522"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>collect</b> (size_t nrMatrices,...)</td></tr>
<tr class="memitem:a24d3ad0252f91f0ec301593c45cf5af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a24d3ad0252f91f0ec301593c45cf5af7">vector_scale_inplace</a> (const Vector &amp;v, Matrix &amp;A, bool inf_mask=false)</td></tr>
<tr class="memdesc:a24d3ad0252f91f0ec301593c45cf5af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scales a matrix row or column by the values in a vector Arguments (Matrix, Vector) scales the columns, (Vector, Matrix) scales the rows  <a href="#a24d3ad0252f91f0ec301593c45cf5af7"></a><br/></td></tr>
<tr class="memitem:a5bc4f0fb9712cc419aa8ff8b6d8fe407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc4f0fb9712cc419aa8ff8b6d8fe407"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>vector_scale</b> (const Vector &amp;v, const Matrix &amp;A, bool inf_mask)</td></tr>
<tr class="memitem:a67cd7ba6f30e1e9cf47239535630c7c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67cd7ba6f30e1e9cf47239535630c7c6"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>vector_scale</b> (const Matrix &amp;A, const Vector &amp;v, bool inf_mask)</td></tr>
<tr class="memitem:a60bc5c23cdae085b88d12056c7411463"><td class="memItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a60bc5c23cdae085b88d12056c7411463">skewSymmetric</a> (double wx, double wy, double wz)</td></tr>
<tr class="memdesc:a60bc5c23cdae085b88d12056c7411463"><td class="mdescLeft">&#160;</td><td class="mdescRight">skew symmetric matrix returns this: 0 -wz wy wz 0 -wx -wy wx 0  <a href="#a60bc5c23cdae085b88d12056c7411463"></a><br/></td></tr>
<tr class="memitem:a60d6f844b3fc9874c46f1a753aa03489"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a60d6f844b3fc9874c46f1a753aa03489">LLt</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a60d6f844b3fc9874c46f1a753aa03489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical Recipes in C wrappers create Numerical Recipes in C structure pointers are subtracted by one to provide base 1 access.  <a href="#a60d6f844b3fc9874c46f1a753aa03489"></a><br/></td></tr>
<tr class="memitem:a2b05b69489f07d74d392d6abf17c644c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b05b69489f07d74d392d6abf17c644c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a2b05b69489f07d74d392d6abf17c644c">RtR</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a2b05b69489f07d74d392d6abf17c644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the R^tR decomposition of a S.P.D matrix. <br/></td></tr>
<tr class="memitem:aba542e2cd85f08b76f80a0871a4ea713"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aba542e2cd85f08b76f80a0871a4ea713">cholesky_inverse</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aba542e2cd85f08b76f80a0871a4ea713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse of a S.P.D.  <a href="#aba542e2cd85f08b76f80a0871a4ea713"></a><br/></td></tr>
<tr class="memitem:aff78dee59ac0250432081f39deb5f6d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff78dee59ac0250432081f39deb5f6d1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aff78dee59ac0250432081f39deb5f6d1">inverse_square_root</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aff78dee59ac0250432081f39deb5f6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use SVD to calculate inverse square root of a matrix. <br/></td></tr>
<tr class="memitem:a8d7e46204d953f64a39445599dbd7eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8d7e46204d953f64a39445599dbd7eee">svd</a> (const Matrix &amp;A, Matrix &amp;U, Vector &amp;S, Matrix &amp;V)</td></tr>
<tr class="memdesc:a8d7e46204d953f64a39445599dbd7eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SVD computes economy SVD A=U*S*V'.  <a href="#a8d7e46204d953f64a39445599dbd7eee"></a><br/></td></tr>
<tr class="memitem:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; int, double, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab2c65f1a69009a306b6a5f9ef31dcee2">DLT</a> (const Matrix &amp;A, double rank_tol=1e-9)</td></tr>
<tr class="memdesc:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct linear transform algorithm that calls svd to find a vector v that minimizes the algebraic error A*v.  <a href="#ab2c65f1a69009a306b6a5f9ef31dcee2"></a><br/></td></tr>
<tr class="memitem:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab15462d8c16813d0a7a5b1f76a2f64b7">expm</a> (const Matrix &amp;A, size_t K=7)</td></tr>
<tr class="memdesc:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical exponential map, naive approach, not industrial strength !!!  <a href="#ab15462d8c16813d0a7a5b1f76a2f64b7"></a><br/></td></tr>
<tr class="memitem:a83d760d40eb1c3e3e214bcb853e488e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d760d40eb1c3e3e214bcb853e488e0"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a83d760d40eb1c3e3e214bcb853e488e0">Cayley</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a83d760d40eb1c3e3e214bcb853e488e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cayley transform. <br/></td></tr>
<tr class="memitem:a166855b51631b94f1f8ab64820c98f29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a166855b51631b94f1f8ab64820c98f29"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a166855b51631b94f1f8ab64820c98f29">Matrix_</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a166855b51631b94f1f8ab64820c98f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from Vector yielding v.size()*1 vector <br/></td></tr>
<tr class="memitem:ae683ac9fd3c4679ddde00872d37f0975"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ae683ac9fd3c4679ddde00872d37f0975">eye</a> (size_t m)</td></tr>
<tr class="memdesc:ae683ac9fd3c4679ddde00872d37f0975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a square identity matrix, with matlab-like syntax.  <a href="#ae683ac9fd3c4679ddde00872d37f0975"></a><br/></td></tr>
<tr class="memitem:af31e657258505b2e5148846ebbaa3195"><td class="memTemplParams" colspan="2"><a class="anchor" id="af31e657258505b2e5148846ebbaa3195"></a>
template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:af31e657258505b2e5148846ebbaa3195"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#af31e657258505b2e5148846ebbaa3195">equal_with_abs_tol</a> (const Eigen::DenseBase&lt; MATRIX &gt; &amp;A, const Eigen::DenseBase&lt; MATRIX &gt; &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:af31e657258505b2e5148846ebbaa3195"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance <br/></td></tr>
<tr class="memitem:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5b3cf3f54adcbdd6d9e7403f1a792f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#afd5b3cf3f54adcbdd6d9e7403f1a792f">operator==</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality is just equal_with_abs_tol 1e-9 <br/></td></tr>
<tr class="memitem:ab235abf7505b634be2165e0db58239dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab235abf7505b634be2165e0db58239dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab235abf7505b634be2165e0db58239dd">operator!=</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ab235abf7505b634be2165e0db58239dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality <br/></td></tr>
<tr class="memitem:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc29e3164ed30e785a3c48dfd1aa6ca5"></a>
template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memTemplItemLeft" align="right" valign="top">MATRIX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#abc29e3164ed30e785a3c48dfd1aa6ca5">prod</a> (const MATRIX &amp;A, const MATRIX &amp;B)</td></tr>
<tr class="memdesc:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">products using old-style format to improve compatibility <br/></td></tr>
<tr class="memitem:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; const MATRIX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aed6673ca73bb7ab59f46f08e3a5cc284">sub</a> (const MATRIX &amp;A, size_t i1, size_t i2, size_t j1, size_t j2)</td></tr>
<tr class="memdesc:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract submatrix, slice semantics, i.e.  <a href="#aed6673ca73bb7ab59f46f08e3a5cc284"></a><br/></td></tr>
<tr class="memitem:a559dba69e2854eb66e34222f60f55722"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a559dba69e2854eb66e34222f60f55722"><td class="memTemplItemLeft" align="right" valign="top">const MATRIX::ConstColXpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a559dba69e2854eb66e34222f60f55722">column</a> (const MATRIX &amp;A, size_t j)</td></tr>
<tr class="memdesc:a559dba69e2854eb66e34222f60f55722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a column view from a matrix that avoids a copy.  <a href="#a559dba69e2854eb66e34222f60f55722"></a><br/></td></tr>
<tr class="memitem:a2754f325c8600303d627d9e8cf1f9949"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a2754f325c8600303d627d9e8cf1f9949"><td class="memTemplItemLeft" align="right" valign="top">const MATRIX::ConstRowXpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a2754f325c8600303d627d9e8cf1f9949">row</a> (const MATRIX &amp;A, size_t j)</td></tr>
<tr class="memdesc:a2754f325c8600303d627d9e8cf1f9949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a row view from a matrix that avoids a copy.  <a href="#a2754f325c8600303d627d9e8cf1f9949"></a><br/></td></tr>
<tr class="memitem:a57edf6ed7312f63d35f73233665c334d"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a57edf6ed7312f63d35f73233665c334d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a57edf6ed7312f63d35f73233665c334d">zeroBelowDiagonal</a> (MATRIX &amp;A, size_t cols=0)</td></tr>
<tr class="memdesc:a57edf6ed7312f63d35f73233665c334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros all of the elements below the diagonal of a matrix, in place.  <a href="#a57edf6ed7312f63d35f73233665c334d"></a><br/></td></tr>
<tr class="memitem:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e36d7ab63000feddaeb61bbfcf2db1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa2e36d7ab63000feddaeb61bbfcf2db1">trans</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">static transpose function, just calls Eigen transpose member function <br/></td></tr>
<tr class="memitem:a1dc9a38f15c24872e82b504fa9761340"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a1dc9a38f15c24872e82b504fa9761340"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a1dc9a38f15c24872e82b504fa9761340">inplace_QR</a> (MATRIX &amp;A)</td></tr>
<tr class="memdesc:a1dc9a38f15c24872e82b504fa9761340"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR factorization using Eigen's internal block QR algorithm.  <a href="#a1dc9a38f15c24872e82b504fa9761340"></a><br/></td></tr>
<tr class="memitem:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a699b5cddc5e7e10eb543c57a728a8b4b"></a>
template&lt;class Derived &gt; </td></tr>
<tr class="memitem:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memTemplItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skewSymmetric</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;w)</td></tr>
<tr class="memitem:a21d18623b1b79e06fb05a73e609b89c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a21d18623b1b79e06fb05a73e609b89c3"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a21d18623b1b79e06fb05a73e609b89c3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a21d18623b1b79e06fb05a73e609b89c3">Cayley</a> (const Eigen::Matrix&lt; double, N, N &gt; &amp;A)</td></tr>
<tr class="memdesc:a21d18623b1b79e06fb05a73e609b89c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Cayley transform using fixed size matrices to let Eigen do more optimization. <br/></td></tr>
<tr class="memitem:a7633e808bfb81359f2bef2fde0a81ce3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7633e808bfb81359f2bef2fde0a81ce3"></a>
<a class="el" href="a00125.html">LieVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7633e808bfb81359f2bef2fde0a81ce3">makeLieVector</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a7633e808bfb81359f2bef2fde0a81ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">global functions for converting to a <a class="el" href="a00125.html" title="LieVector is a wrapper around vector to allow it to be a Lie type.">LieVector</a> for use with numericalDerivative <br/></td></tr>
<tr class="memitem:aaa93f41b5b8a3a701c0ca3322d2c6818"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa93f41b5b8a3a701c0ca3322d2c6818"></a>
<a class="el" href="a00125.html">LieVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeLieVectorD</b> (double d)</td></tr>
<tr class="memitem:ac1beb78285325fde6182c86eb18ae2eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1beb78285325fde6182c86eb18ae2eb"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ac1beb78285325fde6182c86eb18ae2eb"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#ac1beb78285325fde6182c86eb18ae2eb">numericalGradient</a> (boost::function&lt; double(const X &amp;)&gt; h, const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:ac1beb78285325fde6182c86eb18ae2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerically compute gradient of scalar function Class X is the input argument The class X needs to have dim, expmap, logmap. <br/></td></tr>
<tr class="memitem:a52d310374003f3fec5b618b129c8cc21"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52d310374003f3fec5b618b129c8cc21"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a52d310374003f3fec5b618b129c8cc21"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalGradient</b> (double(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a168905f3fbaf00610d4dc486bcc4365b"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a168905f3fbaf00610d4dc486bcc4365b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a168905f3fbaf00610d4dc486bcc4365b">numericalDerivative11</a> (boost::function&lt; Y(const X &amp;)&gt; h, const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a168905f3fbaf00610d4dc486bcc4365b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of unary function.  <a href="#a168905f3fbaf00610d4dc486bcc4365b"></a><br/></td></tr>
<tr class="memitem:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b375fb6b8c69d2cfbf9f1d132464a0c"></a>
template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a3b375fb6b8c69d2cfbf9f1d132464a0c">numericalDerivative11</a> (Y(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br/></td></tr>
<tr class="memitem:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fe4866aa69f0146c6af20f60bc69ddb"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a6fe4866aa69f0146c6af20f60bc69ddb">numericalDerivative11</a> (double(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">remapping for double valued functions <br/></td></tr>
<tr class="memitem:a57f5c58b0716833841299b1f10def7a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57f5c58b0716833841299b1f10def7a7"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a57f5c58b0716833841299b1f10def7a7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a57f5c58b0716833841299b1f10def7a7">numericalDerivative11</a> (boost::function&lt; Vector(const X &amp;)&gt; h, const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a57f5c58b0716833841299b1f10def7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">remapping for vector valued functions <br/></td></tr>
<tr class="memitem:abb5ee7979792a1055f578b9f9de103dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb5ee7979792a1055f578b9f9de103dc"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:abb5ee7979792a1055f578b9f9de103dc"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative11</b> (Vector(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:aeaaad2ac19febd86f2afa7c6916659b9"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:aeaaad2ac19febd86f2afa7c6916659b9"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aeaaad2ac19febd86f2afa7c6916659b9">numericalDerivative21</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aeaaad2ac19febd86f2afa7c6916659b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of binary function.  <a href="#aeaaad2ac19febd86f2afa7c6916659b9"></a><br/></td></tr>
<tr class="memitem:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9714f8cdfe7a86a48d7791b80891fbb3"></a>
template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a9714f8cdfe7a86a48d7791b80891fbb3">numericalDerivative21</a> (Y(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br/></td></tr>
<tr class="memitem:a53aecd57c15f4263e261d40ebb91ce16"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53aecd57c15f4263e261d40ebb91ce16"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a53aecd57c15f4263e261d40ebb91ce16"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a53aecd57c15f4263e261d40ebb91ce16">numericalDerivative21</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a53aecd57c15f4263e261d40ebb91ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="memitem:a28c798b6a7489350b8a57803db51ede1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28c798b6a7489350b8a57803db51ede1"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a28c798b6a7489350b8a57803db51ede1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative21</b> (double(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a79b328b8c696bf16801ac833efbfe2d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79b328b8c696bf16801ac833efbfe2d7"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a79b328b8c696bf16801ac833efbfe2d7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a79b328b8c696bf16801ac833efbfe2d7">numericalDerivative21</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a79b328b8c696bf16801ac833efbfe2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="memitem:ac044fe197ee3e237f0fdd8a57d9ab2cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac044fe197ee3e237f0fdd8a57d9ab2cc"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ac044fe197ee3e237f0fdd8a57d9ab2cc"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative21</b> (Vector(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:ad054ef564f08a62522b456cf677502a8"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ad054ef564f08a62522b456cf677502a8"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#ad054ef564f08a62522b456cf677502a8">numericalDerivative22</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:ad054ef564f08a62522b456cf677502a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of binary function.  <a href="#ad054ef564f08a62522b456cf677502a8"></a><br/></td></tr>
<tr class="memitem:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60ba223711d4313a98d5d6bf1cb3bb50"></a>
template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a60ba223711d4313a98d5d6bf1cb3bb50">numericalDerivative22</a> (Y(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br/></td></tr>
<tr class="memitem:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ac6b4100f0ceb05aabb839e43eaf801"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a5ac6b4100f0ceb05aabb839e43eaf801">numericalDerivative22</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="memitem:a3e0dff8d7fa549c1af1962382d4f51a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e0dff8d7fa549c1af1962382d4f51a5"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a3e0dff8d7fa549c1af1962382d4f51a5"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative22</b> (double(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a9aac9371e141372ece47a166850ebf8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9aac9371e141372ece47a166850ebf8b"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a9aac9371e141372ece47a166850ebf8b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a9aac9371e141372ece47a166850ebf8b">numericalDerivative22</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a9aac9371e141372ece47a166850ebf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="memitem:ae3a29e4a4726a270e36395d2ee79350d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae3a29e4a4726a270e36395d2ee79350d"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ae3a29e4a4726a270e36395d2ee79350d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative22</b> (Vector(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:af6cefcc2e690755b40d84f04beb123ea"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:af6cefcc2e690755b40d84f04beb123ea"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#af6cefcc2e690755b40d84f04beb123ea">numericalDerivative31</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:af6cefcc2e690755b40d84f04beb123ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of ternary function.  <a href="#af6cefcc2e690755b40d84f04beb123ea"></a><br/></td></tr>
<tr class="memitem:a42b0f07ac2b1b629ccc8b106a924bf5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42b0f07ac2b1b629ccc8b106a924bf5d"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a42b0f07ac2b1b629ccc8b106a924bf5d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a49ff733799ed93622a896fea47eeef62"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49ff733799ed93622a896fea47eeef62"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a49ff733799ed93622a896fea47eeef62"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a49ff733799ed93622a896fea47eeef62">numericalDerivative31</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a49ff733799ed93622a896fea47eeef62"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="memitem:a60341eefc0af912a79e003444e92cd5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60341eefc0af912a79e003444e92cd5d"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a60341eefc0af912a79e003444e92cd5d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (double(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a1151b40cc04229cfeb05e2b226189446"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1151b40cc04229cfeb05e2b226189446"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a1151b40cc04229cfeb05e2b226189446"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a1151b40cc04229cfeb05e2b226189446">numericalDerivative31</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a1151b40cc04229cfeb05e2b226189446"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="memitem:a834cf2d4648127f7cbaac7331ba49f88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a834cf2d4648127f7cbaac7331ba49f88"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a834cf2d4648127f7cbaac7331ba49f88"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (Vector(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a0b4fe49c0dea74639a95bfb58e21e663"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a0b4fe49c0dea74639a95bfb58e21e663"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a0b4fe49c0dea74639a95bfb58e21e663">numericalDerivative32</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a0b4fe49c0dea74639a95bfb58e21e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of ternary function.  <a href="#a0b4fe49c0dea74639a95bfb58e21e663"></a><br/></td></tr>
<tr class="memitem:ad3a1820eeacd9a217d922ae731e2b3c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3a1820eeacd9a217d922ae731e2b3c1"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ad3a1820eeacd9a217d922ae731e2b3c1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:af40d267127fa96699dc26c27a11d4e87"><td class="memTemplParams" colspan="2"><a class="anchor" id="af40d267127fa96699dc26c27a11d4e87"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:af40d267127fa96699dc26c27a11d4e87"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#af40d267127fa96699dc26c27a11d4e87">numericalDerivative32</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:af40d267127fa96699dc26c27a11d4e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="memitem:a2c8ab5de702d754bc646dc39b75f38e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c8ab5de702d754bc646dc39b75f38e1"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a2c8ab5de702d754bc646dc39b75f38e1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (double(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8cea897ac1b1b5ccbdd0825167ed057c"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a8cea897ac1b1b5ccbdd0825167ed057c">numericalDerivative32</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="memitem:ac2fd3c53635d94771e6f5c874664cff4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2fd3c53635d94771e6f5c874664cff4"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ac2fd3c53635d94771e6f5c874664cff4"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (Vector(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a5def64a08dde6bc660af18e22f69e901"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a5def64a08dde6bc660af18e22f69e901"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a5def64a08dde6bc660af18e22f69e901">numericalDerivative33</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a5def64a08dde6bc660af18e22f69e901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 3 of ternary function.  <a href="#a5def64a08dde6bc660af18e22f69e901"></a><br/></td></tr>
<tr class="memitem:a732a2a9a5a4b3c8135e1468a0e676904"><td class="memTemplParams" colspan="2"><a class="anchor" id="a732a2a9a5a4b3c8135e1468a0e676904"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a732a2a9a5a4b3c8135e1468a0e676904"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8fc2cab4819a3df2a7730072cf37a1d"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aa8fc2cab4819a3df2a7730072cf37a1d">numericalDerivative33</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="memitem:a57ee23fac2c8efd5cd50b5ca0a379ee1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57ee23fac2c8efd5cd50b5ca0a379ee1"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a57ee23fac2c8efd5cd50b5ca0a379ee1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (double(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:aa265046959ca82909006caa5b2eda199"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa265046959ca82909006caa5b2eda199"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aa265046959ca82909006caa5b2eda199"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aa265046959ca82909006caa5b2eda199">numericalDerivative33</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aa265046959ca82909006caa5b2eda199"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="memitem:a93115f439799b0f1190c704c50df63e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93115f439799b0f1190c704c50df63e6"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a93115f439799b0f1190c704c50df63e6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (Vector(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a11dc11c40862fe22c0ebab881edda95a"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a11dc11c40862fe22c0ebab881edda95a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a11dc11c40862fe22c0ebab881edda95a">numericalHessian</a> (boost::function&lt; double(const X &amp;)&gt; f, const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a11dc11c40862fe22c0ebab881edda95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical Hessian matrix.  <a href="#a11dc11c40862fe22c0ebab881edda95a"></a><br/></td></tr>
<tr class="memitem:ad1592f546980d76c01e3908fe2a378de"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1592f546980d76c01e3908fe2a378de"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ad1592f546980d76c01e3908fe2a378de"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian</b> (double(*f)(const X &amp;), const X &amp;x, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:aadc8958584ec5a638019dc0c9d9975e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadc8958584ec5a638019dc0c9d9975e7"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:aadc8958584ec5a638019dc0c9d9975e7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian212</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a409737480df475024208ff6d2f1f68e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a409737480df475024208ff6d2f1f68e4"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a409737480df475024208ff6d2f1f68e4"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian212</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:add3fd63ff6037e3e8ffae054dcf63666"><td class="memTemplParams" colspan="2"><a class="anchor" id="add3fd63ff6037e3e8ffae054dcf63666"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:add3fd63ff6037e3e8ffae054dcf63666"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian211</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a9bc6fe88faa11ab553d828d79ba23aab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bc6fe88faa11ab553d828d79ba23aab"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a9bc6fe88faa11ab553d828d79ba23aab"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian211</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a1abf0cfba34349c2d4c12b4d7c03c122"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1abf0cfba34349c2d4c12b4d7c03c122"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a1abf0cfba34349c2d4c12b4d7c03c122"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian222</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a3fbe72395d442afe872574fd8b9ddb7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3fbe72395d442afe872574fd8b9ddb7d"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a3fbe72395d442afe872574fd8b9ddb7d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian222</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:aa0b0105665f1374c98ee7707e3d35d97"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0b0105665f1374c98ee7707e3d35d97"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aa0b0105665f1374c98ee7707e3d35d97"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aa0b0105665f1374c98ee7707e3d35d97">numericalHessian311</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aa0b0105665f1374c98ee7707e3d35d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical Hessian for tenary functions. <br/></td></tr>
<tr class="memitem:abcdf9aba21acf8f054bbead3f50198ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="abcdf9aba21acf8f054bbead3f50198ae"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:abcdf9aba21acf8f054bbead3f50198ae"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian311</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a6bd8c734e71cead717573fd0aaefe3c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6bd8c734e71cead717573fd0aaefe3c4"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a6bd8c734e71cead717573fd0aaefe3c4"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian322</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:ae9ed93a8becceb3b101286db9c320b42"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9ed93a8becceb3b101286db9c320b42"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ae9ed93a8becceb3b101286db9c320b42"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian322</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a347346234e1e94248602a7486019c827"><td class="memTemplParams" colspan="2"><a class="anchor" id="a347346234e1e94248602a7486019c827"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a347346234e1e94248602a7486019c827"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian333</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a1f42cef3df34ae6117340347704ba988"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f42cef3df34ae6117340347704ba988"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a1f42cef3df34ae6117340347704ba988"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian333</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:af63fbe41ccbcda42c062f63c44833c46"><td class="memTemplParams" colspan="2"><a class="anchor" id="af63fbe41ccbcda42c062f63c44833c46"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:af63fbe41ccbcda42c062f63c44833c46"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian312</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a07e62093361a6ae91efb33871c776598"><td class="memTemplParams" colspan="2"><a class="anchor" id="a07e62093361a6ae91efb33871c776598"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a07e62093361a6ae91efb33871c776598"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian313</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:aee14c56bb3c0dee17ffd2b3b4d6862c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee14c56bb3c0dee17ffd2b3b4d6862c3"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aee14c56bb3c0dee17ffd2b3b4d6862c3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian323</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a5ce2f7a50b649415b17e9cb0dab15582"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ce2f7a50b649415b17e9cb0dab15582"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a5ce2f7a50b649415b17e9cb0dab15582"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian312</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:afe4ffd1a329bc0f1e9e76a047d623924"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe4ffd1a329bc0f1e9e76a047d623924"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:afe4ffd1a329bc0f1e9e76a047d623924"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian313</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:abac11116d2d3ca642db967f4bd5fa28d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abac11116d2d3ca642db967f4bd5fa28d"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:abac11116d2d3ca642db967f4bd5fa28d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian323</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memitem:a332bad7d1e70d3c04ceca35adce7a134"><td class="memTemplParams" colspan="2"><a class="anchor" id="a332bad7d1e70d3c04ceca35adce7a134"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a332bad7d1e70d3c04ceca35adce7a134"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const T &amp;input)</td></tr>
<tr class="memitem:aa4d516d0d98946341ad2766521011d1b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4d516d0d98946341ad2766521011d1b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4d516d0d98946341ad2766521011d1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (const std::string &amp;serialized, T &amp;output)</td></tr>
<tr class="memitem:aa3261c2d455f892dae1921f8c3a39267"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3261c2d455f892dae1921f8c3a39267"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa3261c2d455f892dae1921f8c3a39267"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToFile</b> (const T &amp;input, const std::string &amp;filename)</td></tr>
<tr class="memitem:adbb4a71187706918faca3a11519b62f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbb4a71187706918faca3a11519b62f6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adbb4a71187706918faca3a11519b62f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromFile</b> (const std::string &amp;filename, T &amp;output)</td></tr>
<tr class="memitem:a976ff7999fcc13ef602b6ece1b078bca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a976ff7999fcc13ef602b6ece1b078bca"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a976ff7999fcc13ef602b6ece1b078bca"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeXML</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85ab51b2e8f4cea69f72e06a5c136e85"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeXML</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:a89449123a746480a1d668cecb5576708"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89449123a746480a1d668cecb5576708"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a89449123a746480a1d668cecb5576708"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToXMLFile</b> (const T &amp;input, const std::string &amp;filename, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d8faf2bb0a908ff484677bb2fcf707c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromXMLFile</b> (const std::string &amp;filename, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:abb476c3e77878f7e0f70dd51871f48e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb476c3e77878f7e0f70dd51871f48e7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abb476c3e77878f7e0f70dd51871f48e7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeBinary</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:a56c41958e57a4bc7361ab593011462fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56c41958e57a4bc7361ab593011462fd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a56c41958e57a4bc7361ab593011462fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeBinary</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:ab3ee0c39b3f937c15594ee87b27d3e09"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3ee0c39b3f937c15594ee87b27d3e09"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab3ee0c39b3f937c15594ee87b27d3e09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeToBinaryFile</b> (const T &amp;input, const std::string &amp;filename, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefeb77f2324e4bbfca2c8152c49a4565"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromBinaryFile</b> (const std::string &amp;filename, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="memitem:a04f25326667c8e905e3a7065ece2b307"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04f25326667c8e905e3a7065ece2b307"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a04f25326667c8e905e3a7065ece2b307"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a04f25326667c8e905e3a7065ece2b307">print</a> (const T &amp;object, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="memdesc:a04f25326667c8e905e3a7065ece2b307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call print on the object. <br/></td></tr>
<tr class="memitem:ad2dbee4a72127938c79162cc8b6d5152"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2dbee4a72127938c79162cc8b6d5152"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad2dbee4a72127938c79162cc8b6d5152"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#ad2dbee4a72127938c79162cc8b6d5152">equal</a> (const T &amp;obj1, const T &amp;obj2, double tol)</td></tr>
<tr class="memdesc:ad2dbee4a72127938c79162cc8b6d5152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call equal on the object. <br/></td></tr>
<tr class="memitem:a1f3dc67ad88b799c469088e428c583b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f3dc67ad88b799c469088e428c583b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f3dc67ad88b799c469088e428c583b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a1f3dc67ad88b799c469088e428c583b1">equal</a> (const T &amp;obj1, const T &amp;obj2)</td></tr>
<tr class="memdesc:a1f3dc67ad88b799c469088e428c583b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call equal on the object without tolerance (use default tolerance) <br/></td></tr>
<tr class="memitem:a659619cca082d1c10b07c033d48c54da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a659619cca082d1c10b07c033d48c54da"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a659619cca082d1c10b07c033d48c54da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a659619cca082d1c10b07c033d48c54da">assert_equal</a> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a659619cca082d1c10b07c033d48c54da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template works for any type with equals. <br/></td></tr>
<tr class="memitem:a334553734f411aa7492ee5e940e9ad74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334553734f411aa7492ee5e940e9ad74"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a334553734f411aa7492ee5e940e9ad74">assert_equal</a> (const <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> &amp;expected, const <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> &amp;actual, double tol=0.0)</td></tr>
<tr class="memdesc:a334553734f411aa7492ee5e940e9ad74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals testing for basic types. <br/></td></tr>
<tr class="memitem:add6d6575582314cc9b5dbdbe2a86374d"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:add6d6575582314cc9b5dbdbe2a86374d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#add6d6575582314cc9b5dbdbe2a86374d">assert_equal</a> (const boost::optional&lt; V &gt; &amp;expected, const boost::optional&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:add6d6575582314cc9b5dbdbe2a86374d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparisons for boost.optional objects that checks whether objects exist before comparing their values.  <a href="#add6d6575582314cc9b5dbdbe2a86374d"></a><br/></td></tr>
<tr class="memitem:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb156f7b9ac630cc6fd956b386cf1dab"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const boost::optional&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memitem:a5242be27f83219abc3f9793975986a35"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5242be27f83219abc3f9793975986a35"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a5242be27f83219abc3f9793975986a35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const boost::optional&lt; const V &amp; &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memitem:a0931276a9406dfc1bcff6d265704ee39"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0931276a9406dfc1bcff6d265704ee39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a0931276a9406dfc1bcff6d265704ee39">assert_equal</a> (const std::vector&lt; V &gt; &amp;expected, const std::vector&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a0931276a9406dfc1bcff6d265704ee39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of assert_equals to work with vectors.  <a href="#a0931276a9406dfc1bcff6d265704ee39"></a><br/></td></tr>
<tr class="memitem:a254be27d6d4b416fa2b546c77ae783fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a254be27d6d4b416fa2b546c77ae783fc"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a254be27d6d4b416fa2b546c77ae783fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a254be27d6d4b416fa2b546c77ae783fc">assert_container_equal</a> (const std::map&lt; V1, V2 &gt; &amp;expected, const std::map&lt; V1, V2 &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a254be27d6d4b416fa2b546c77ae783fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of testable-&gt;testable TODO: replace with more generalized version. <br/></td></tr>
<tr class="memitem:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f509195ea2180d0f7dbd3a99a088ff4"></a>
template&lt;class V2 &gt; </td></tr>
<tr class="memitem:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a2f509195ea2180d0f7dbd3a99a088ff4">assert_container_equal</a> (const std::map&lt; size_t, V2 &gt; &amp;expected, const std::map&lt; size_t, V2 &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of size_t-&gt;testable. <br/></td></tr>
<tr class="memitem:a0eec17f894b358dd9f30d7af28082ba5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0eec17f894b358dd9f30d7af28082ba5"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a0eec17f894b358dd9f30d7af28082ba5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a0eec17f894b358dd9f30d7af28082ba5">assert_container_equal</a> (const std::vector&lt; std::pair&lt; V1, V2 &gt; &gt; &amp;expected, const std::vector&lt; std::pair&lt; V1, V2 &gt; &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a0eec17f894b358dd9f30d7af28082ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing vector of pairs (testable, testable) <br/></td></tr>
<tr class="memitem:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d6b2964354593f69848f6bf5d3e0ca1"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a6d6b2964354593f69848f6bf5d3e0ca1">assert_container_equal</a> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for comparing containers of testable objects. <br/></td></tr>
<tr class="memitem:a59ba6a7db27344c5cb021f1421905020"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59ba6a7db27344c5cb021f1421905020"></a>
template&lt;class V2 &gt; </td></tr>
<tr class="memitem:a59ba6a7db27344c5cb021f1421905020"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a59ba6a7db27344c5cb021f1421905020">assert_container_equality</a> (const std::map&lt; size_t, V2 &gt; &amp;expected, const std::map&lt; size_t, V2 &gt; &amp;actual)</td></tr>
<tr class="memdesc:a59ba6a7db27344c5cb021f1421905020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of size_t-&gt;testable Types are assumed to have operator ==. <br/></td></tr>
<tr class="memitem:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0926a5d779171bd8e1d30fb5982b5c0"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aa0926a5d779171bd8e1d30fb5982b5c0">assert_container_equality</a> (const V &amp;expected, const V &amp;actual)</td></tr>
<tr class="memdesc:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for comparing containers of objects with operator==. <br/></td></tr>
<tr class="memitem:a21e760bc75888053afd86a27d56b6148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21e760bc75888053afd86a27d56b6148"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a21e760bc75888053afd86a27d56b6148">assert_equal</a> (const std::string &amp;expected, const std::string &amp;actual)</td></tr>
<tr class="memdesc:a21e760bc75888053afd86a27d56b6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings for unit tests. <br/></td></tr>
<tr class="memitem:a2f19ba6625a264457805513fefcb5c32"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f19ba6625a264457805513fefcb5c32"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a2f19ba6625a264457805513fefcb5c32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a2f19ba6625a264457805513fefcb5c32">assert_inequal</a> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a2f19ba6625a264457805513fefcb5c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow for testing inequality. <br/></td></tr>
<tr class="memitem:a3230ae4ee4a803cf8d837ea66a735703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3230ae4ee4a803cf8d837ea66a735703"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_finishedIteration_</b> ()</td></tr>
<tr class="memitem:a4733cdc946435aef61a5478b201d1042"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4733cdc946435aef61a5478b201d1042"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_print_</b> ()</td></tr>
<tr class="memitem:a7945a7256f5f54c8fcf0c2aa1bf4b3f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7945a7256f5f54c8fcf0c2aa1bf4b3f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_print2_</b> ()</td></tr>
<tr class="memitem:a05e469989c2312c6c5ccb33b1202ef41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e469989c2312c6c5ccb33b1202ef41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_reset_</b> ()</td></tr>
<tr class="memitem:a16e1907e78ef60b7e2bb474e6be77e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e1907e78ef60b7e2bb474e6be77e54"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_defaultIndexFormatter</b> (<a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> j)</td></tr>
<tr class="memitem:adc8725ddddd5e780177cf69df55df2f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8725ddddd5e780177cf69df55df2f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>odprintf_</b> (const char *format, ostream &amp;stream,...)</td></tr>
<tr class="memitem:a5f9a97513901635b46a3149bea00fad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9a97513901635b46a3149bea00fad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a5f9a97513901635b46a3149bea00fad7">odprintf</a> (const char *format,...)</td></tr>
<tr class="memdesc:a5f9a97513901635b46a3149bea00fad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auxiliary function to printf for Win32 compatibility, added by Kai. <br/></td></tr>
<tr class="memitem:ab57c9f2befdc8ef07099fd46a1292196"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57c9f2befdc8ef07099fd46a1292196"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab57c9f2befdc8ef07099fd46a1292196">Vector_</a> (size_t m, const double *const data)</td></tr>
<tr class="memdesc:ab57c9f2befdc8ef07099fd46a1292196"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with size and initial data, row order ! <br/></td></tr>
<tr class="memitem:aa6d467994413740aa0f65f458aed0222"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d467994413740aa0f65f458aed0222"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa6d467994413740aa0f65f458aed0222">Vector_</a> (size_t m,...)</td></tr>
<tr class="memdesc:aa6d467994413740aa0f65f458aed0222"><td class="mdescLeft">&#160;</td><td class="mdescRight">nice constructor, dangerous as number of arguments must be exactly right and you have to pass doubles !!! always use 0.0 never 0 <br/></td></tr>
<tr class="memitem:a19ebecb2fedfd16881bd5a9ab842c144"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19ebecb2fedfd16881bd5a9ab842c144"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a19ebecb2fedfd16881bd5a9ab842c144">Vector_</a> (const std::vector&lt; double &gt; &amp;data)</td></tr>
<tr class="memdesc:a19ebecb2fedfd16881bd5a9ab842c144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numeric vector from an STL vector of doubles. <br/></td></tr>
<tr class="memitem:a33561b8886a11b2de66f9dab4c7380e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33561b8886a11b2de66f9dab4c7380e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a33561b8886a11b2de66f9dab4c7380e3">zero</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a33561b8886a11b2de66f9dab4c7380e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if all zero <br/></td></tr>
<tr class="memitem:af50343afb840c2e690b5b86b69ab691a"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af50343afb840c2e690b5b86b69ab691a">repeat</a> (size_t n, double value)</td></tr>
<tr class="memdesc:af50343afb840c2e690b5b86b69ab691a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create vector initialized to a constant value.  <a href="#af50343afb840c2e690b5b86b69ab691a"></a><br/></td></tr>
<tr class="memitem:ac2a0ba4a7a13e0f4c781fa9de3e5689e"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a> (size_t n, size_t i, double value)</td></tr>
<tr class="memdesc:ac2a0ba4a7a13e0f4c781fa9de3e5689e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create basis vector of dimension n, with a constant in spot i.  <a href="#ac2a0ba4a7a13e0f4c781fa9de3e5689e"></a><br/></td></tr>
<tr class="memitem:ad264e350453db2df8b12f66c670ad0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad264e350453db2df8b12f66c670ad0e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad264e350453db2df8b12f66c670ad0e7">print</a> (const Vector &amp;v, const std::string &amp;s=&quot;&quot;, std::ostream &amp;stream=std::cout)</td></tr>
<tr class="memdesc:ad264e350453db2df8b12f66c670ad0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string <br/></td></tr>
<tr class="memitem:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09f2bbdb9f9d633542362dbe8d79f9ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a09f2bbdb9f9d633542362dbe8d79f9ab">save</a> (const Vector &amp;A, const std::string &amp;s, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a vector to file, which can be loaded by matlab <br/></td></tr>
<tr class="memitem:a64988014ab746343803620dc42513646"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64988014ab746343803620dc42513646"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a64988014ab746343803620dc42513646">operator==</a> (const Vector &amp;vec1, const Vector &amp;vec2)</td></tr>
<tr class="memdesc:a64988014ab746343803620dc42513646"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00243.html#afd5b3cf3f54adcbdd6d9e7403f1a792f" title="equality is just equal_with_abs_tol 1e-9">operator==()</a> <br/></td></tr>
<tr class="memitem:a368ee40bd9c0124d572d2e49bcb077bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a368ee40bd9c0124d572d2e49bcb077bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a368ee40bd9c0124d572d2e49bcb077bf">greaterThanOrEqual</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a368ee40bd9c0124d572d2e49bcb077bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to operation returns true if all elements in v1 are greater than corresponding elements in v2. <br/></td></tr>
<tr class="memitem:a8bdced1844ffd6a53af0396d82eaa6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bdced1844ffd6a53af0396d82eaa6da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8bdced1844ffd6a53af0396d82eaa6da">equal_with_abs_tol</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a8bdced1844ffd6a53af0396d82eaa6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">VecA == VecB up to tolerance. <br/></td></tr>
<tr class="memitem:a14034da7e28c95db712ec344d4a2ffaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14034da7e28c95db712ec344d4a2ffaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal_with_abs_tol</b> (const SubVector &amp;vec1, const SubVector &amp;vec2, double tol)</td></tr>
<tr class="memitem:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9f3ee662d25ffb8c04b4e35c4b02e90b">assert_equal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, prints if error.  <a href="#a9f3ee662d25ffb8c04b4e35c4b02e90b"></a><br/></td></tr>
<tr class="memitem:a2ca3db47b15350977c1f03c5560ab332"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a2ca3db47b15350977c1f03c5560ab332">assert_inequal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a2ca3db47b15350977c1f03c5560ab332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not the same, prints if error.  <a href="#a2ca3db47b15350977c1f03c5560ab332"></a><br/></td></tr>
<tr class="memitem:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ac3cf8e8e70cd696d9c789c31bc1e89a7">assert_equal</a> (const SubVector &amp;vec1, const SubVector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, prints if error.  <a href="#ac3cf8e8e70cd696d9c789c31bc1e89a7"></a><br/></td></tr>
<tr class="memitem:ac95292df1087c65aa5b5388bf4c11842"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95292df1087c65aa5b5388bf4c11842"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const ConstSubVector &amp;expected, const ConstSubVector &amp;actual, double tol)</td></tr>
<tr class="memitem:a2a0cfd7908b06491df49b6a9c9186775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a2a0cfd7908b06491df49b6a9c9186775">linear_dependent</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a2a0cfd7908b06491df49b6a9c9186775"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether two vectors are linearly dependent  <a href="#a2a0cfd7908b06491df49b6a9c9186775"></a><br/></td></tr>
<tr class="memitem:af694dd7a0838c24e3484068cc1657f4a"><td class="memItemLeft" align="right" valign="top">ConstSubVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af694dd7a0838c24e3484068cc1657f4a">sub</a> (const Vector &amp;v, size_t i1, size_t i2)</td></tr>
<tr class="memdesc:af694dd7a0838c24e3484068cc1657f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract subvector, slice semantics, i.e.  <a href="#af694dd7a0838c24e3484068cc1657f4a"></a><br/></td></tr>
<tr class="memitem:abe442f79470225ffccfc8bc5ce46a87a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#abe442f79470225ffccfc8bc5ce46a87a">subInsert</a> (Vector &amp;fullVector, const Vector &amp;subVector, size_t i)</td></tr>
<tr class="memdesc:abe442f79470225ffccfc8bc5ce46a87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a subvector into a vector IN PLACE.  <a href="#abe442f79470225ffccfc8bc5ce46a87a"></a><br/></td></tr>
<tr class="memitem:ab08665ce2fa3fdc3f7ff6d87b26452cc"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab08665ce2fa3fdc3f7ff6d87b26452cc">emul</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:ab08665ce2fa3fdc3f7ff6d87b26452cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiplication  <a href="#ab08665ce2fa3fdc3f7ff6d87b26452cc"></a><br/></td></tr>
<tr class="memitem:ac0d4fbafe5819f4617da45c107b3e616"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ac0d4fbafe5819f4617da45c107b3e616">ediv</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:ac0d4fbafe5819f4617da45c107b3e616"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division  <a href="#ac0d4fbafe5819f4617da45c107b3e616"></a><br/></td></tr>
<tr class="memitem:a14844c96706dc362917e0d5e76d65fbe"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a14844c96706dc362917e0d5e76d65fbe">ediv_</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:a14844c96706dc362917e0d5e76d65fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division, but 0/0 = 0, not inf  <a href="#a14844c96706dc362917e0d5e76d65fbe"></a><br/></td></tr>
<tr class="memitem:a316a9f631367da3caae876b41b345867"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a316a9f631367da3caae876b41b345867">sum</a> (const Vector &amp;a)</td></tr>
<tr class="memdesc:a316a9f631367da3caae876b41b345867"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum vector elements  <a href="#a316a9f631367da3caae876b41b345867"></a><br/></td></tr>
<tr class="memitem:aaa3ddc32a5a6b8eed2d5efe69d1cb171"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aaa3ddc32a5a6b8eed2d5efe69d1cb171">norm_2</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:aaa3ddc32a5a6b8eed2d5efe69d1cb171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates L2 norm for a vector modeled after boost.ublas for compatibility.  <a href="#aaa3ddc32a5a6b8eed2d5efe69d1cb171"></a><br/></td></tr>
<tr class="memitem:a0853fc18973e23bb407825df52c95515"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a0853fc18973e23bb407825df52c95515">reciprocal</a> (const Vector &amp;a)</td></tr>
<tr class="memdesc:a0853fc18973e23bb407825df52c95515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise reciprocal of vector elements.  <a href="#a0853fc18973e23bb407825df52c95515"></a><br/></td></tr>
<tr class="memitem:a6c974066d393d86d744e9d387f0d3f50"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a6c974066d393d86d744e9d387f0d3f50">esqrt</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a6c974066d393d86d744e9d387f0d3f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise sqrt of vector elements.  <a href="#a6c974066d393d86d744e9d387f0d3f50"></a><br/></td></tr>
<tr class="memitem:a5ba06101b45d9f2647608cbf4e3b35aa"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a5ba06101b45d9f2647608cbf4e3b35aa">abs</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a5ba06101b45d9f2647608cbf4e3b35aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute values of vector elements.  <a href="#a5ba06101b45d9f2647608cbf4e3b35aa"></a><br/></td></tr>
<tr class="memitem:ab21cbc51fd8128a843739dbe5e0b2421"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab21cbc51fd8128a843739dbe5e0b2421">max</a> (const Vector &amp;a)</td></tr>
<tr class="memdesc:ab21cbc51fd8128a843739dbe5e0b2421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the max element of a vector.  <a href="#ab21cbc51fd8128a843739dbe5e0b2421"></a><br/></td></tr>
<tr class="memitem:ac9c0c05b0198ec0fb6e4115edb755910"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9c0c05b0198ec0fb6e4115edb755910"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ac9c0c05b0198ec0fb6e4115edb755910">houseInPlace</a> (Vector &amp;x)</td></tr>
<tr class="memdesc:ac9c0c05b0198ec0fb6e4115edb755910"><td class="mdescLeft">&#160;</td><td class="mdescRight">beta = house(x) computes the HouseHolder vector in place <br/></td></tr>
<tr class="memitem:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="memItemLeft" align="right" valign="top">pair&lt; double, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#afb77eefc25dea0fb3e0fcc8f246b617a">house</a> (const Vector &amp;x)</td></tr>
<tr class="memdesc:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">house(x,j) computes HouseHolder vector v and scaling factor beta from x, such that the corresponding Householder reflection zeroes out all but x.  <a href="#afb77eefc25dea0fb3e0fcc8f246b617a"></a><br/></td></tr>
<tr class="memitem:aca3f9d6140621a7e935f051d8fb23284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3f9d6140621a7e935f051d8fb23284"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>weightedPseudoinverse</b> (const Vector &amp;a, const Vector &amp;weights, Vector &amp;pseudo)</td></tr>
<tr class="memitem:aca1c56d11a05464a7a5458dc32ccc777"><td class="memItemLeft" align="right" valign="top">pair&lt; Vector, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aca1c56d11a05464a7a5458dc32ccc777">weightedPseudoinverse</a> (const Vector &amp;v, const Vector &amp;weights)</td></tr>
<tr class="memdesc:aca1c56d11a05464a7a5458dc32ccc777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted Householder solution vector, a.k.a., the pseudoinverse of the column NOTE: if any sigmas are zero (indicating a constraint) the pseudoinverse will be a selection vector, and the variance will be zero.  <a href="#aca1c56d11a05464a7a5458dc32ccc777"></a><br/></td></tr>
<tr class="memitem:ae1c88acfa9575bcea3f2e738cb637a85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c88acfa9575bcea3f2e738cb637a85"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ae1c88acfa9575bcea3f2e738cb637a85">concatVectors</a> (const std::list&lt; Vector &gt; &amp;vs)</td></tr>
<tr class="memdesc:ae1c88acfa9575bcea3f2e738cb637a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate Vectors <br/></td></tr>
<tr class="memitem:a09610ec69a8b3f3a00399bb378eda9cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09610ec69a8b3f3a00399bb378eda9cf"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a09610ec69a8b3f3a00399bb378eda9cf">concatVectors</a> (size_t nrVectors,...)</td></tr>
<tr class="memdesc:a09610ec69a8b3f3a00399bb378eda9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate Vectors <br/></td></tr>
<tr class="memitem:a6ec32e8dafe1d25ab11de3d693c1b5a4"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a6ec32e8dafe1d25ab11de3d693c1b5a4">basis</a> (size_t n, size_t i)</td></tr>
<tr class="memdesc:a6ec32e8dafe1d25ab11de3d693c1b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create basis vector of dimension n, with one in spot i.  <a href="#a6ec32e8dafe1d25ab11de3d693c1b5a4"></a><br/></td></tr>
<tr class="memitem:a067f9515f6cd64987f4604127398fb9d"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a067f9515f6cd64987f4604127398fb9d">zero</a> (size_t n)</td></tr>
<tr class="memdesc:a067f9515f6cd64987f4604127398fb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create zero vector.  <a href="#a067f9515f6cd64987f4604127398fb9d"></a><br/></td></tr>
<tr class="memitem:aa4782bb65cdbe1fdd391080d1754a20f"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa4782bb65cdbe1fdd391080d1754a20f">ones</a> (size_t n)</td></tr>
<tr class="memdesc:aa4782bb65cdbe1fdd391080d1754a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create vector initialized to ones.  <a href="#aa4782bb65cdbe1fdd391080d1754a20f"></a><br/></td></tr>
<tr class="memitem:a3740ee8f898205aa46c6b3f78fbb817a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3740ee8f898205aa46c6b3f78fbb817a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3740ee8f898205aa46c6b3f78fbb817a">dim</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a3740ee8f898205aa46c6b3f78fbb817a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dimensionality == size <br/></td></tr>
<tr class="memitem:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ed1d4fe2dd6828cfeb2d8f488b818d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa7ed1d4fe2dd6828cfeb2d8f488b818d">equal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol)</td></tr>
<tr class="memdesc:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of equal in <a class="el" href="a00227.html" title="Base class and basic functions for Lie types.">Lie.h</a>. <br/></td></tr>
<tr class="memitem:a3d1cad2313f69f9fa5008fdc348d1526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1cad2313f69f9fa5008fdc348d1526"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3d1cad2313f69f9fa5008fdc348d1526">equal</a> (const Vector &amp;vec1, const Vector &amp;vec2)</td></tr>
<tr class="memdesc:a3d1cad2313f69f9fa5008fdc348d1526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of equal in <a class="el" href="a00227.html" title="Base class and basic functions for Lie types.">Lie.h</a>. <br/></td></tr>
<tr class="memitem:ad80249acf12bbea741e755cd8fc73042"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad80249acf12bbea741e755cd8fc73042"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad80249acf12bbea741e755cd8fc73042"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#ad80249acf12bbea741e755cd8fc73042">dot</a> (const V1 &amp;a, const V2 &amp;b)</td></tr>
<tr class="memdesc:ad80249acf12bbea741e755cd8fc73042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product. <br/></td></tr>
<tr class="memitem:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a4ca41ba9ec9d6d21a2b9f5e00f9f25ed">inner_prod</a> (const V1 &amp;a, const V2 &amp;b)</td></tr>
<tr class="memdesc:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compatibility version for ublas' <a class="el" href="a00243.html#a4ca41ba9ec9d6d21a2b9f5e00f9f25ed" title="compatibility version for ublas&#39; inner_prod()">inner_prod()</a> <br/></td></tr>
<tr class="memitem:ad371582718b5e685ace31c176f2a9abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad371582718b5e685ace31c176f2a9abc">scal</a> (double alpha, Vector &amp;x)</td></tr>
<tr class="memdesc:ad371582718b5e685ace31c176f2a9abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 scal: x &lt;- alpha*x.  <a href="#ad371582718b5e685ace31c176f2a9abc"></a><br/></td></tr>
<tr class="memitem:a30a89a0147943428129e2cb3683988be"><td class="memTemplParams" colspan="2">template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a30a89a0147943428129e2cb3683988be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a30a89a0147943428129e2cb3683988be">axpy</a> (double alpha, const V1 &amp;x, V2 &amp;y)</td></tr>
<tr class="memdesc:a30a89a0147943428129e2cb3683988be"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 axpy: y &lt;- alpha*x + y.  <a href="#a30a89a0147943428129e2cb3683988be"></a><br/></td></tr>
<tr class="memitem:a6947eb9313cdaf0a67bbc333e57e387f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6947eb9313cdaf0a67bbc333e57e387f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>axpy</b> (double alpha, const Vector &amp;x, SubVector y)</td></tr>
<tr class="memitem:ab498ebc225b8ecec9c0176a7460b9da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab498ebc225b8ecec9c0176a7460b9da5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab498ebc225b8ecec9c0176a7460b9da5">INSTANTIATE_LIE</a> (<a class="el" href="a00157.html">Point2</a>)</td></tr>
<tr class="memdesc:ab498ebc225b8ecec9c0176a7460b9da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="memitem:aaca17bb555bb1993e5e821aee707bd75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaca17bb555bb1993e5e821aee707bd75"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00157.html">Point2</a> &amp;p)</td></tr>
<tr class="memitem:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63d86e99c211c6daeac2b7b4dd9d928e"></a>
<a class="el" href="a00157.html">Point2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a63d86e99c211c6daeac2b7b4dd9d928e">operator*</a> (double s, const <a class="el" href="a00157.html">Point2</a> &amp;p)</td></tr>
<tr class="memdesc:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply with scalar <br/></td></tr>
<tr class="memitem:a0574540374ca7142a55b370d4237a1ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0574540374ca7142a55b370d4237a1ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a0574540374ca7142a55b370d4237a1ec">INSTANTIATE_LIE</a> (<a class="el" href="a00158.html">Point3</a>)</td></tr>
<tr class="memdesc:a0574540374ca7142a55b370d4237a1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="memitem:ac70fc23d4149c33874a82a4de29b13f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac70fc23d4149c33874a82a4de29b13f4"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00158.html">Point3</a> &amp;p)</td></tr>
<tr class="memitem:a27247b810d31840d7d3fefc2b73c99af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27247b810d31840d7d3fefc2b73c99af"></a>
<a class="el" href="a00158.html">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a27247b810d31840d7d3fefc2b73c99af">operator*</a> (double s, const <a class="el" href="a00158.html">Point3</a> &amp;p)</td></tr>
<tr class="memdesc:a27247b810d31840d7d3fefc2b73c99af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic sugar for multiplying coordinates by a scalar s*p. <br/></td></tr>
<tr class="memitem:a9b449384ab2bdade1dc9fdb857011606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b449384ab2bdade1dc9fdb857011606"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9b449384ab2bdade1dc9fdb857011606">INSTANTIATE_LIE</a> (<a class="el" href="a00159.html">Pose2</a>)</td></tr>
<tr class="memdesc:a9b449384ab2bdade1dc9fdb857011606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="memitem:ad6efe09721c5221b12b7a3437f0a2bee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6efe09721c5221b12b7a3437f0a2bee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad6efe09721c5221b12b7a3437f0a2bee">GTSAM_CONCEPT_POSE_INST</a> (<a class="el" href="a00159.html">Pose2</a>)</td></tr>
<tr class="memdesc:ad6efe09721c5221b12b7a3437f0a2bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">instantiate concept checks <br/></td></tr>
<tr class="memitem:a2d5f3d592b1eb52ab4bf4d34003178f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d5f3d592b1eb52ab4bf4d34003178f0"></a>
boost::optional&lt; <a class="el" href="a00159.html">Pose2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (const vector&lt; <a class="el" href="a00243.html#af15dec8cc8bf0a43bc649709b84cf771">Point2Pair</a> &gt; &amp;pairs)</td></tr>
<tr class="memitem:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b78f4db0e05f3ca838ee4da6187710e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a4b78f4db0e05f3ca838ee4da6187710e">wedge&lt; Pose2 &gt;</a> (const Vector &amp;xi)</td></tr>
<tr class="memdesc:a4b78f4db0e05f3ca838ee4da6187710e"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for pose2 wedge function (generic template in <a class="el" href="a00227.html" title="Base class and basic functions for Lie types.">Lie.h</a>) <br/></td></tr>
<tr class="memitem:acbeda702e320c082a99bb717a69b017c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbeda702e320c082a99bb717a69b017c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#acbeda702e320c082a99bb717a69b017c">INSTANTIATE_LIE</a> (<a class="el" href="a00160.html">Pose3</a>)</td></tr>
<tr class="memdesc:acbeda702e320c082a99bb717a69b017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="memitem:a10a8e9793b8e0d234fb0c83b17a2f5bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a8e9793b8e0d234fb0c83b17a2f5bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a10a8e9793b8e0d234fb0c83b17a2f5bc">GTSAM_CONCEPT_POSE_INST</a> (<a class="el" href="a00160.html">Pose3</a>)</td></tr>
<tr class="memdesc:a10a8e9793b8e0d234fb0c83b17a2f5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">instantiate concept checks <br/></td></tr>
<tr class="memitem:a016eba8839e800a867207d7126551217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a016eba8839e800a867207d7126551217"></a>
boost::optional&lt; <a class="el" href="a00160.html">Pose3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (const vector&lt; <a class="el" href="a00243.html#a450a25bc3b2e869f58054168b1262213">Point3Pair</a> &gt; &amp;pairs)</td></tr>
<tr class="memitem:a7c070c867687a63dc5da15b6f1d12004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c070c867687a63dc5da15b6f1d12004"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00160.html">Pose3</a> &amp;pose)</td></tr>
<tr class="memitem:aefb606eb24889c0f418acf1515a2c723"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aefb606eb24889c0f418acf1515a2c723"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aefb606eb24889c0f418acf1515a2c723">wedge&lt; Pose3 &gt;</a> (const Vector &amp;xi)</td></tr>
<tr class="memdesc:aefb606eb24889c0f418acf1515a2c723"><td class="mdescLeft">&#160;</td><td class="mdescRight">wedge for <a class="el" href="a00160.html">Pose3</a>:  <a href="#aefb606eb24889c0f418acf1515a2c723"></a><br/></td></tr>
<tr class="memitem:a53676b6c16dc20cf5f31f13251230c2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53676b6c16dc20cf5f31f13251230c2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a53676b6c16dc20cf5f31f13251230c2f">INSTANTIATE_LIE</a> (<a class="el" href="a00174.html">Rot2</a>)</td></tr>
<tr class="memdesc:a53676b6c16dc20cf5f31f13251230c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="memitem:a9d06ed5dc919a7d92968509198d40361"><td class="memItemLeft" align="right" valign="top">GTSAM_EXPORT std::pair<br class="typebreak"/>
&lt; Matrix3, Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9d06ed5dc919a7d92968509198d40361">RQ</a> (const Matrix3 &amp;A)</td></tr>
<tr class="memdesc:a9d06ed5dc919a7d92968509198d40361"><td class="mdescLeft">&#160;</td><td class="mdescRight">[RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R and 3 rotation angles corresponding to the rotation matrix Q=Qz'*Qy'*Qx' such that A = R*Q = R*Qz'*Qy'*Qx'.  <a href="#a9d06ed5dc919a7d92968509198d40361"></a><br/></td></tr>
<tr class="memitem:aff82ceb2b15cc6592d74bc48a8542588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff82ceb2b15cc6592d74bc48a8542588"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00175.html">Rot3</a> &amp;R)</td></tr>
<tr class="memitem:a9b6a2b4b6a6423eb8c49ae4fad1ef790"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b6a2b4b6a6423eb8c49ae4fad1ef790"></a>
<a class="el" href="a00243.html#a7bb03eb3dceb63b0933c94c15b83cb39">SimpleCamera</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9b6a2b4b6a6423eb8c49ae4fad1ef790">simpleCamera</a> (const Matrix &amp;P)</td></tr>
<tr class="memdesc:a9b6a2b4b6a6423eb8c49ae4fad1ef790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover camera from 3*4 camera matrix. <br/></td></tr>
<tr class="memitem:a1ca06c457b0f62d18110230bb930d626"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ca06c457b0f62d18110230bb930d626"></a>
template&lt;class CONDITIONAL , class CLIQUE &gt; </td></tr>
<tr class="memitem:a1ca06c457b0f62d18110230bb930d626"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_sharedCliques</b> (const typename <a class="el" href="a00010.html">BayesTree</a>&lt; CONDITIONAL, CLIQUE &gt;::sharedClique &amp;v1, const typename <a class="el" href="a00010.html">BayesTree</a>&lt; CONDITIONAL, CLIQUE &gt;::sharedClique &amp;v2)</td></tr>
<tr class="memitem:ade4071c734bff2fd4c0160a511dea582"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade4071c734bff2fd4c0160a511dea582"></a>
template&lt;class CONDITIONAL , class CLIQUE &gt; </td></tr>
<tr class="memitem:ade4071c734bff2fd4c0160a511dea582"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_BayesTree_dim_adder</b> (std::vector&lt; size_t &gt; &amp;dims, const typename <a class="el" href="a00010.html">BayesTree</a>&lt; CONDITIONAL, CLIQUE &gt;::sharedClique &amp;clique)</td></tr>
<tr class="memitem:a85d0e35e59e87bf6cfcdf37dd0845b2b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85d0e35e59e87bf6cfcdf37dd0845b2b"></a>
template&lt;class CONDITIONAL , class CLIQUE &gt; </td></tr>
<tr class="memitem:a85d0e35e59e87bf6cfcdf37dd0845b2b"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="a00210.html">VectorValues</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocateVectorValues</b> (const <a class="el" href="a00010.html">BayesTree</a>&lt; CONDITIONAL, CLIQUE &gt; &amp;bt)</td></tr>
<tr class="memitem:a88299e1d80238aae66edef85e352c903"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88299e1d80238aae66edef85e352c903"></a>
template&lt;class DERIVED , class CONDITIONAL &gt; </td></tr>
<tr class="memitem:a88299e1d80238aae66edef85e352c903"><td class="memTemplItemLeft" align="right" valign="top">const DERIVED *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asDerived</b> (const <a class="el" href="a00012.html">BayesTreeCliqueBase</a>&lt; DERIVED, CONDITIONAL &gt; *base)</td></tr>
<tr class="memitem:aa2ff26ba844ee75912276b1b8a1536c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2ff26ba844ee75912276b1b8a1536c1"></a>
template&lt;class DERIVED , class CONDITIONAL &gt; </td></tr>
<tr class="memitem:aa2ff26ba844ee75912276b1b8a1536c1"><td class="memTemplItemLeft" align="right" valign="top">DERIVED *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asDerived</b> (<a class="el" href="a00012.html">BayesTreeCliqueBase</a>&lt; DERIVED, CONDITIONAL &gt; *base)</td></tr>
<tr class="memitem:aadd9c566c2b0b790e2dbcddeaab28877"><td class="memTemplParams" colspan="2">template&lt;class FACTORGRAPH &gt; </td></tr>
<tr class="memitem:aadd9c566c2b0b790e2dbcddeaab28877"><td class="memTemplItemLeft" align="right" valign="top">FACTORGRAPH&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aadd9c566c2b0b790e2dbcddeaab28877">combine</a> (const FACTORGRAPH &amp;fg1, const FACTORGRAPH &amp;fg2)</td></tr>
<tr class="memdesc:aadd9c566c2b0b790e2dbcddeaab28877"><td class="mdescLeft">&#160;</td><td class="mdescRight">static function that combines two factor graphs  <a href="#aadd9c566c2b0b790e2dbcddeaab28877"></a><br/></td></tr>
<tr class="memitem:ab7e6b80f69dbd7d1457d9dc5f45ebc17"><td class="memTemplParams" colspan="2">template&lt;class DERIVEDFACTOR , class KEY &gt; </td></tr>
<tr class="memitem:ab7e6b80f69dbd7d1457d9dc5f45ebc17"><td class="memTemplItemLeft" align="right" valign="top">DERIVEDFACTOR::shared_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#ab7e6b80f69dbd7d1457d9dc5f45ebc17">Combine</a> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; DERIVEDFACTOR &gt; &amp;factors, const <a class="el" href="a00068.html">FastMap</a>&lt; KEY, std::vector&lt; KEY &gt; &gt; &amp;variableSlots)</td></tr>
<tr class="memdesc:ab7e6b80f69dbd7d1457d9dc5f45ebc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a combined joint factor (new style for <a class="el" href="a00059.html" title="An elimination tree is a data structure used intermediately during elimination.">EliminationTree</a>).  <a href="#ab7e6b80f69dbd7d1457d9dc5f45ebc17"></a><br/></td></tr>
<tr class="memitem:a67ce120ccb443373c83ac4a3ebb298f8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67ce120ccb443373c83ac4a3ebb298f8"></a>
template&lt;class FACTOR , class CONDITIONAL , class CLIQUE &gt; </td></tr>
<tr class="memitem:a67ce120ccb443373c83ac4a3ebb298f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_FactorGraph_BayesTree_adder</b> (std::vector&lt; typename boost::shared_ptr&lt; FACTOR &gt; &gt; &amp;factors_io, const typename <a class="el" href="a00010.html">BayesTree</a>&lt; CONDITIONAL, CLIQUE &gt;::sharedClique &amp;clique)</td></tr>
<tr class="memitem:a18a265afdea057ea54be10262396be12"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18a265afdea057ea54be10262396be12"></a>
template&lt;class KEY &gt; </td></tr>
<tr class="memitem:a18a265afdea057ea54be10262396be12"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a18a265afdea057ea54be10262396be12">predecessorMap2Keys</a> (const <a class="el" href="a00165.html">PredecessorMap</a>&lt; KEY &gt; &amp;p_map)</td></tr>
<tr class="memdesc:a18a265afdea057ea54be10262396be12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a list of keys from a spanning tree represented by its predecessor map. <br/></td></tr>
<tr class="memitem:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c0319a6ebcc83d4a5cf9ff51729bb80"></a>
template&lt;class G , class F , class KEY &gt; </td></tr>
<tr class="memitem:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00178.html">SDGraph</a>&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a6c0319a6ebcc83d4a5cf9ff51729bb80">toBoostGraph</a> (const G &amp;graph)</td></tr>
<tr class="memdesc:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the factor graph to an <a class="el" href="a00178.html" title="SDGraph is undirected graph with variable keys and double edge weights.">SDGraph</a> G = Graph type F = <a class="el" href="a00064.html" title="This is the base class for all factor types.">Factor</a> type Key = Key type. <br/></td></tr>
<tr class="memitem:ae67d0d86c4e55b175859967a70b36983"><td class="memTemplParams" colspan="2">template&lt;class G , class V , class KEY &gt; </td></tr>
<tr class="memitem:ae67d0d86c4e55b175859967a70b36983"><td class="memTemplItemLeft" align="right" valign="top">boost::tuple&lt; G, V, std::map<br class="typebreak"/>
&lt; KEY, V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#ae67d0d86c4e55b175859967a70b36983">predecessorMap2Graph</a> (const <a class="el" href="a00165.html">PredecessorMap</a>&lt; KEY &gt; &amp;p_map)</td></tr>
<tr class="memdesc:ae67d0d86c4e55b175859967a70b36983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build takes a predecessor map, and builds a directed graph corresponding to the tree.  <a href="#ae67d0d86c4e55b175859967a70b36983"></a><br/></td></tr>
<tr class="memitem:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62b34d6038ccdfa84d8a5bb0c15328b1"></a>
template&lt;class G , class Factor , class POSE , class KEY &gt; </td></tr>
<tr class="memitem:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="a00202.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a62b34d6038ccdfa84d8a5bb0c15328b1">composePoses</a> (const G &amp;graph, const <a class="el" href="a00165.html">PredecessorMap</a>&lt; KEY &gt; &amp;tree, const POSE &amp;rootPose)</td></tr>
<tr class="memdesc:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the poses by following the chain specified by the spanning tree. <br/></td></tr>
<tr class="memitem:a7771a103b41708e88763ff67059ff01d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7771a103b41708e88763ff67059ff01d"></a>
template&lt;class G , class KEY , class FACTOR2 &gt; </td></tr>
<tr class="memitem:a7771a103b41708e88763ff67059ff01d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00165.html">PredecessorMap</a>&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a7771a103b41708e88763ff67059ff01d">findMinimumSpanningTree</a> (const G &amp;g)</td></tr>
<tr class="memdesc:a7771a103b41708e88763ff67059ff01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the minimum spanning tree using boost graph library <br/></td></tr>
<tr class="memitem:a3453247aec1d8b4642947ffd4bca426b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3453247aec1d8b4642947ffd4bca426b"></a>
template&lt;class G , class KEY , class FACTOR2 &gt; </td></tr>
<tr class="memitem:a3453247aec1d8b4642947ffd4bca426b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a3453247aec1d8b4642947ffd4bca426b">split</a> (const G &amp;g, const <a class="el" href="a00165.html">PredecessorMap</a>&lt; KEY &gt; &amp;tree, G &amp;Ab1, G &amp;Ab2)</td></tr>
<tr class="memdesc:a3453247aec1d8b4642947ffd4bca426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the graph into two parts: one corresponds to the given spanning tree, and the other corresponds to the rest of the factors. <br/></td></tr>
<tr class="memitem:a5781266d49d769387b952e51d26b5d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00099.html#a9dfa70fd9d54fe62a5898102a911e542">IndexFactor::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a5781266d49d769387b952e51d26b5d67">CombineSymbolic</a> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00099.html">IndexFactor</a> &gt; &amp;factors, const <a class="el" href="a00068.html">FastMap</a>&lt; <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a>, std::vector&lt; <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> &gt; &gt; &amp;variableSlots)</td></tr>
<tr class="memdesc:a5781266d49d769387b952e51d26b5d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a combined joint factor (new style for <a class="el" href="a00059.html" title="An elimination tree is a data structure used intermediately during elimination.">EliminationTree</a>).  <a href="#a5781266d49d769387b952e51d26b5d67"></a><br/></td></tr>
<tr class="memitem:a98334f29148f20bd7f7300f2b48d76bc"><td class="memItemLeft" align="right" valign="top">pair<br class="typebreak"/>
&lt; IndexConditional::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00099.html#a9dfa70fd9d54fe62a5898102a911e542">IndexFactor::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a98334f29148f20bd7f7300f2b48d76bc">EliminateSymbolic</a> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00099.html">IndexFactor</a> &gt; &amp;, size_t nrFrontals=1)</td></tr>
<tr class="memdesc:a98334f29148f20bd7f7300f2b48d76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CombineAndEliminate provides symbolic elimination.  <a href="#a98334f29148f20bd7f7300f2b48d76bc"></a><br/></td></tr>
<tr class="memitem:a35831074a7aab15d463acddc7767bfe8"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a35831074a7aab15d463acddc7767bfe8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00005.html">Assignment</a>&lt; L &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a35831074a7aab15d463acddc7767bfe8">cartesianProduct</a> (const std::vector&lt; std::pair&lt; L, size_t &gt; &gt; &amp;keys)</td></tr>
<tr class="memdesc:a35831074a7aab15d463acddc7767bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Cartesian product consisting all possible configurations.  <a href="#a35831074a7aab15d463acddc7767bfe8"></a><br/></td></tr>
<tr class="memitem:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf36c31dcf9f45f5bbdfd2b80f07cd1f"></a>
template&lt;typename Y , typename L &gt; </td></tr>
<tr class="memitem:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#abf36c31dcf9f45f5bbdfd2b80f07cd1f">apply</a> (const <a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt; &amp;f, const typename <a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt;::Unary &amp;op)</td></tr>
<tr class="memdesc:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">free versions of apply <br/></td></tr>
<tr class="memitem:a3aa0c47ab0d861b59ac13096141b7b0d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3aa0c47ab0d861b59ac13096141b7b0d"></a>
template&lt;typename Y , typename L &gt; </td></tr>
<tr class="memitem:a3aa0c47ab0d861b59ac13096141b7b0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (const <a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt; &amp;f, const <a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt; &amp;g, const typename <a class="el" href="a00041.html">DecisionTree</a>&lt; L, Y &gt;::Binary &amp;op)</td></tr>
<tr class="memitem:a7fc5a18f1729ac625d3a5cafd3b2a9b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fc5a18f1729ac625d3a5cafd3b2a9b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7fc5a18f1729ac625d3a5cafd3b2a9b8">add_front</a> (<a class="el" href="a00009.html">DiscreteBayesNet</a> &amp;, const <a class="el" href="a00180.html">Signature</a> &amp;s)</td></tr>
<tr class="memdesc:a7fc5a18f1729ac625d3a5cafd3b2a9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a DiscreteCondtional in front, when listing parents first. <br/></td></tr>
<tr class="memitem:a2873cd7da108fe4ec3c4b3de299271ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2873cd7da108fe4ec3c4b3de299271ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a2873cd7da108fe4ec3c4b3de299271ec">add</a> (<a class="el" href="a00009.html">DiscreteBayesNet</a> &amp;, const <a class="el" href="a00180.html">Signature</a> &amp;s)</td></tr>
<tr class="memdesc:a2873cd7da108fe4ec3c4b3de299271ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a DiscreteCondtional. <br/></td></tr>
<tr class="memitem:a9f8577aa81bd6efd3ea90cb44f2a8cf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f8577aa81bd6efd3ea90cb44f2a8cf4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>evaluate</b> (const <a class="el" href="a00009.html">DiscreteBayesNet</a> &amp;bn, const <a class="el" href="a00047.html#af60ddbcb414927280bf1aa4dcd9cd0a9">DiscreteConditional::Values</a> &amp;values)</td></tr>
<tr class="memitem:a358cd7b51eb4d286b177a29a5df85d07"><td class="memItemLeft" align="right" valign="top">DiscreteFactor::sharedValues&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a358cd7b51eb4d286b177a29a5df85d07">optimize</a> (const <a class="el" href="a00009.html">DiscreteBayesNet</a> &amp;bn)</td></tr>
<tr class="memdesc:a358cd7b51eb4d286b177a29a5df85d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize function for back-substitution.  <a href="#a358cd7b51eb4d286b177a29a5df85d07"></a><br/></td></tr>
<tr class="memitem:a7181110a8a65413eb829dd71fd35d86a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7181110a8a65413eb829dd71fd35d86a"></a>
DiscreteFactor::sharedValues&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7181110a8a65413eb829dd71fd35d86a">sample</a> (const <a class="el" href="a00009.html">DiscreteBayesNet</a> &amp;bn)</td></tr>
<tr class="memdesc:a7181110a8a65413eb829dd71fd35d86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do ancestral sampling. <br/></td></tr>
<tr class="memitem:a8532ccb083068943c5f1ce1e23cbdb8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8532ccb083068943c5f1ce1e23cbdb8f"></a>
std::pair<br class="typebreak"/>
&lt; DiscreteConditional::shared_ptr, <br class="typebreak"/>
DecisionTreeFactor::shared_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8532ccb083068943c5f1ce1e23cbdb8f">EliminateDiscrete</a> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00048.html">DiscreteFactor</a> &gt; &amp;factors, size_t nrFrontals=1)</td></tr>
<tr class="memdesc:a8532ccb083068943c5f1ce1e23cbdb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main elimination function for <a class="el" href="a00049.html">DiscreteFactorGraph</a>. <br/></td></tr>
<tr class="memitem:a0be4f243161c2fd937df60aee511eb16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0be4f243161c2fd937df60aee511eb16"></a>
<a class="el" href="a00050.html">DiscreteKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a0be4f243161c2fd937df60aee511eb16">operator&amp;</a> (const <a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a> &amp;key1, const <a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a> &amp;key2)</td></tr>
<tr class="memdesc:a0be4f243161c2fd937df60aee511eb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list from two keys. <br/></td></tr>
<tr class="memitem:acb908dc2c6a21befce6367d4d23b0395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb908dc2c6a21befce6367d4d23b0395"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00180.html#a058b129adfd1cdb887c88efedf2c8ca3">Signature::Row</a> &amp;<a class="el" href="a00243.html#a2754f325c8600303d627d9e8cf1f9949">row</a>)</td></tr>
<tr class="memitem:ada56b99f564432dcf54a04a0db7dd178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada56b99f564432dcf54a04a0db7dd178"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00180.html">Signature</a> &amp;s)</td></tr>
<tr class="memitem:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6c58dfb2fc9398a026e3268ba2edfad"></a>
<a class="el" href="a00180.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa6c58dfb2fc9398a026e3268ba2edfad">operator|</a> (const <a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a> &amp;key, const <a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a> &amp;parent)</td></tr>
<tr class="memdesc:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects example: <a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s = D | E;. <br/></td></tr>
<tr class="memitem:ab98cf2a4777006c28d6983db5d8ec574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab98cf2a4777006c28d6983db5d8ec574"></a>
<a class="el" href="a00180.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab98cf2a4777006c28d6983db5d8ec574">operator%</a> (const <a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a> &amp;key, const std::string &amp;parent)</td></tr>
<tr class="memdesc:ab98cf2a4777006c28d6983db5d8ec574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects example: <a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s(D % "99/1"); Uses string parser, which requires BOOST 1.42 or higher. <br/></td></tr>
<tr class="memitem:ae4856250df52ce4b9b4b16c7a833408c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4856250df52ce4b9b4b16c7a833408c"></a>
<a class="el" href="a00180.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ae4856250df52ce4b9b4b16c7a833408c">operator%</a> (const <a class="el" href="a00243.html#a4ee698b6d04431828d60c6c112926876">DiscreteKey</a> &amp;key, const Signature::Table &amp;parent)</td></tr>
<tr class="memdesc:ae4856250df52ce4b9b4b16c7a833408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects, using table construction directly example: <a class="el" href="a00180.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s(D % table);. <br/></td></tr>
<tr class="memitem:a106ec458ddb425604809da93346af55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a106ec458ddb425604809da93346af55d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a106ec458ddb425604809da93346af55d">dot</a> (const <a class="el" href="a00062.html">Errors</a> &amp;a, const <a class="el" href="a00062.html">Errors</a> &amp;b)</td></tr>
<tr class="memdesc:a106ec458ddb425604809da93346af55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product <br/></td></tr>
<tr class="memitem:a939e1342568a5072310bc7995d3cf383"><td class="memTemplParams" colspan="2"><a class="anchor" id="a939e1342568a5072310bc7995d3cf383"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a939e1342568a5072310bc7995d3cf383"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a939e1342568a5072310bc7995d3cf383">axpy&lt; Errors, Errors &gt;</a> (double alpha, const <a class="el" href="a00062.html">Errors</a> &amp;x, <a class="el" href="a00062.html">Errors</a> &amp;y)</td></tr>
<tr class="memdesc:a939e1342568a5072310bc7995d3cf383"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS level 2 style. <br/></td></tr>
<tr class="memitem:a9528f84279a6f9c18d7d5a444735e57a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9528f84279a6f9c18d7d5a444735e57a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9528f84279a6f9c18d7d5a444735e57a">print</a> (const <a class="el" href="a00062.html">Errors</a> &amp;a, const std::string &amp;s=&quot;Error&quot;)</td></tr>
<tr class="memdesc:a9528f84279a6f9c18d7d5a444735e57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string <br/></td></tr>
<tr class="memitem:a420345bb137915bf7d3c7ad9391fa518"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a420345bb137915bf7d3c7ad9391fa518"></a>
<a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a420345bb137915bf7d3c7ad9391fa518">scalarGaussian</a> (<a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> key, double mu=0.0, double sigma=1.0)</td></tr>
<tr class="memdesc:a420345bb137915bf7d3c7ad9391fa518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scalar Gaussian. <br/></td></tr>
<tr class="memitem:a74b2d06896b95507494162a2a02a4156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74b2d06896b95507494162a2a02a4156"></a>
<a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a74b2d06896b95507494162a2a02a4156">simpleGaussian</a> (<a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> key, const Vector &amp;mu, double sigma=1.0)</td></tr>
<tr class="memdesc:a74b2d06896b95507494162a2a02a4156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simple Gaussian on a single multivariate variable. <br/></td></tr>
<tr class="memitem:a43d1569fcd498fd1cfdb2544fe53913a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43d1569fcd498fd1cfdb2544fe53913a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a43d1569fcd498fd1cfdb2544fe53913a">push_front</a> (<a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn, <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> key, Vector d, Matrix R, <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> name1, Matrix S, Vector sigmas)</td></tr>
<tr class="memdesc:a43d1569fcd498fd1cfdb2544fe53913a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a conditional node with one parent |Rx+Sy-d|. <br/></td></tr>
<tr class="memitem:afc981bec474c655f574a18f2ac8a0386"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc981bec474c655f574a18f2ac8a0386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#afc981bec474c655f574a18f2ac8a0386">push_front</a> (<a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn, <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> key, Vector d, Matrix R, <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> name1, Matrix S, <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> name2, Matrix T, Vector sigmas)</td></tr>
<tr class="memdesc:afc981bec474c655f574a18f2ac8a0386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a conditional node with two parents |Rx+Sy+Tz-d|. <br/></td></tr>
<tr class="memitem:a86fbbe1d4059980af59689064b2602f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86fbbe1d4059980af59689064b2602f4"></a>
boost::shared_ptr&lt; <a class="el" href="a00210.html">VectorValues</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a86fbbe1d4059980af59689064b2602f4">allocateVectorValues</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn)</td></tr>
<tr class="memdesc:a86fbbe1d4059980af59689064b2602f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> for the variables in a <a class="el" href="a00009.html" title="A BayesNet is a list of conditionals, stored in elimination order, i.e.">BayesNet</a>. <br/></td></tr>
<tr class="memitem:a3bf6c5f3d6f9d0d8edfed780e74a6b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3bf6c5f3d6f9d0d8edfed780e74a6b92">optimizeInPlace</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn, <a class="el" href="a00210.html">VectorValues</a> &amp;x)</td></tr>
<tr class="memdesc:a3bf6c5f3d6f9d0d8edfed780e74a6b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the GaussianBayesNet, i.e.  <a href="#a3bf6c5f3d6f9d0d8edfed780e74a6b92"></a><br/></td></tr>
<tr class="memitem:a298de6d58b3fc896f87b8dfe8f17ed46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a298de6d58b3fc896f87b8dfe8f17ed46"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a298de6d58b3fc896f87b8dfe8f17ed46">backSubstitute</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn, const <a class="el" href="a00210.html">VectorValues</a> &amp;gx)</td></tr>
<tr class="memdesc:a298de6d58b3fc896f87b8dfe8f17ed46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backsubstitute gy=inv(R*inv(Sigma))*gx. <br/></td></tr>
<tr class="memitem:ac38b470a3484438d87f33b5148484fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ac38b470a3484438d87f33b5148484fbb">backSubstituteTranspose</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn, const <a class="el" href="a00210.html">VectorValues</a> &amp;gx)</td></tr>
<tr class="memdesc:ac38b470a3484438d87f33b5148484fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose Backsubstitute gy=inv(L)*gx by solving L*gy=gx.  <a href="#ac38b470a3484438d87f33b5148484fbb"></a><br/></td></tr>
<tr class="memitem:a07a95b31369c4b864a852d1f1db11875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a07a95b31369c4b864a852d1f1db11875">optimizeGradientSearch</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn)</td></tr>
<tr class="memdesc:a07a95b31369c4b864a852d1f1db11875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize along the gradient direction, with a closed-form computation to perform the line search.  <a href="#a07a95b31369c4b864a852d1f1db11875"></a><br/></td></tr>
<tr class="memitem:a38cc916d8f1f9d6c3e321ec12b8197a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a38cc916d8f1f9d6c3e321ec12b8197a4">optimizeGradientSearchInPlace</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bn, <a class="el" href="a00210.html">VectorValues</a> &amp;grad)</td></tr>
<tr class="memdesc:a38cc916d8f1f9d6c3e321ec12b8197a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place version of <a class="el" href="a00243.html#a07a95b31369c4b864a852d1f1db11875" title="Optimize along the gradient direction, with a closed-form computation to perform the line search...">optimizeGradientSearch(const GaussianBayesNet&amp;)</a> requiring pre-allocated <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> <code>grad</code>.  <a href="#a38cc916d8f1f9d6c3e321ec12b8197a4"></a><br/></td></tr>
<tr class="memitem:aca0469d937a218083628a8f4b7bc9471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca0469d937a218083628a8f4b7bc9471"></a>
pair&lt; Matrix, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aca0469d937a218083628a8f4b7bc9471">matrix</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;)</td></tr>
<tr class="memdesc:aca0469d937a218083628a8f4b7bc9471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (dense) upper-triangular matrix representation. <br/></td></tr>
<tr class="memitem:a437b00f8d2f91de1e7c9646a1e30c697"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a437b00f8d2f91de1e7c9646a1e30c697">determinant</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bayesNet)</td></tr>
<tr class="memdesc:a437b00f8d2f91de1e7c9646a1e30c697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a GassianBayesNet A GaussianBayesNet is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements.  <a href="#a437b00f8d2f91de1e7c9646a1e30c697"></a><br/></td></tr>
<tr class="memitem:a3f4fb4f157ae7441db3c88b2379dfde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3f4fb4f157ae7441db3c88b2379dfde3">gradient</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bayesNet, const <a class="el" href="a00210.html">VectorValues</a> &amp;x0)</td></tr>
<tr class="memdesc:a3f4fb4f157ae7441db3c88b2379dfde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \).  <a href="#a3f4fb4f157ae7441db3c88b2379dfde3"></a><br/></td></tr>
<tr class="memitem:a02f208f5b83fb8c97c7c92aa392715d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a02f208f5b83fb8c97c7c92aa392715d0">gradientAtZero</a> (const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;bayesNet, <a class="el" href="a00210.html">VectorValues</a> &amp;g)</td></tr>
<tr class="memdesc:a02f208f5b83fb8c97c7c92aa392715d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero.  <a href="#a02f208f5b83fb8c97c7c92aa392715d0"></a><br/></td></tr>
<tr class="memitem:a5631ea50b248f953ba6b6541ac748124"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5631ea50b248f953ba6b6541ac748124"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a5631ea50b248f953ba6b6541ac748124">optimize</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree)</td></tr>
<tr class="memdesc:a5631ea50b248f953ba6b6541ac748124"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimize the <a class="el" href="a00010.html">BayesTree</a>, starting from the root <br/></td></tr>
<tr class="memitem:a77b51e5d7b79003a9a324d52583e8681"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b51e5d7b79003a9a324d52583e8681"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a77b51e5d7b79003a9a324d52583e8681">optimizeInPlace</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree, <a class="el" href="a00210.html">VectorValues</a> &amp;result)</td></tr>
<tr class="memdesc:a77b51e5d7b79003a9a324d52583e8681"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively optimize this conditional and all subtrees <br/></td></tr>
<tr class="memitem:a18b805fc8803b45fb43e5f8edbc3edd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a18b805fc8803b45fb43e5f8edbc3edd3">optimizeGradientSearch</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree)</td></tr>
<tr class="memdesc:a18b805fc8803b45fb43e5f8edbc3edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize along the gradient direction, with a closed-form computation to perform the line search.  <a href="#a18b805fc8803b45fb43e5f8edbc3edd3"></a><br/></td></tr>
<tr class="memitem:a17862f31818ae5ab30e524a7a841ce9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17862f31818ae5ab30e524a7a841ce9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a17862f31818ae5ab30e524a7a841ce9b">optimizeGradientSearchInPlace</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree, <a class="el" href="a00210.html">VectorValues</a> &amp;grad)</td></tr>
<tr class="memdesc:a17862f31818ae5ab30e524a7a841ce9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place version of optimizeGradientSearch requiring pre-allocated <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> <code>x</code>. <br/></td></tr>
<tr class="memitem:a7137b3408fcad3c1ebfab25ad42a0d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7137b3408fcad3c1ebfab25ad42a0d89">gradient</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree, const <a class="el" href="a00210.html">VectorValues</a> &amp;x0)</td></tr>
<tr class="memdesc:a7137b3408fcad3c1ebfab25ad42a0d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \).  <a href="#a7137b3408fcad3c1ebfab25ad42a0d89"></a><br/></td></tr>
<tr class="memitem:a58124dacabb4587d323f0a098f4832a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a58124dacabb4587d323f0a098f4832a5">gradientAtZero</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree, <a class="el" href="a00210.html">VectorValues</a> &amp;g)</td></tr>
<tr class="memdesc:a58124dacabb4587d323f0a098f4832a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero.  <a href="#a58124dacabb4587d323f0a098f4832a5"></a><br/></td></tr>
<tr class="memitem:afb635013ae91ee448a08c03a61528f07"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#afb635013ae91ee448a08c03a61528f07">determinant</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree)</td></tr>
<tr class="memdesc:afb635013ae91ee448a08c03a61528f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of a GassianBayesTree A GassianBayesTree is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements.  <a href="#afb635013ae91ee448a08c03a61528f07"></a><br/></td></tr>
<tr class="memitem:a6e52ac8802179bab53e61d2411515e57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a6e52ac8802179bab53e61d2411515e57">logDeterminant</a> (const <a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a> &amp;bayesTree)</td></tr>
<tr class="memdesc:a6e52ac8802179bab53e61d2411515e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the log determinant of a GassianBayesTree A GassianBayesTree is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements.  <a href="#a6e52ac8802179bab53e61d2411515e57"></a><br/></td></tr>
<tr class="memitem:a37ba736c4d9cb6cb9436eb855cdcc22c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ba736c4d9cb6cb9436eb855cdcc22c"></a>
JacobianFactor::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>CombineJacobians</b> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00112.html">JacobianFactor</a> &gt; &amp;factors, const <a class="el" href="a00208.html">VariableSlots</a> &amp;variableSlots)</td></tr>
<tr class="memitem:a1bdd82c40d3ef0ed53a0501c5f5b2c92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bdd82c40d3ef0ed53a0501c5f5b2c92"></a>
<a class="el" href="a00065.html#a043d04c0f33faa4d411243c45a9b5509">GaussianFactorGraph::EliminationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateJacobians</b> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00112.html">JacobianFactor</a> &gt; &amp;factors, size_t nrFrontals)</td></tr>
<tr class="memitem:a4c9a1e54cd73422f11896d21a4ee7b16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9a1e54cd73422f11896d21a4ee7b16"></a>
<a class="el" href="a00065.html#a043d04c0f33faa4d411243c45a9b5509">GaussianFactorGraph::EliminationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateCholesky</b> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00078.html">GaussianFactor</a> &gt; &amp;factors, size_t nrFrontals)</td></tr>
<tr class="memitem:a3a28501d3fdb1b862ce8df4ee254d565"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a28501d3fdb1b862ce8df4ee254d565"></a>
<a class="el" href="a00065.html#a043d04c0f33faa4d411243c45a9b5509">GaussianFactorGraph::EliminationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateQR</b> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00078.html">GaussianFactor</a> &gt; &amp;factors, size_t nrFrontals)</td></tr>
<tr class="memitem:a612323e9be85348e9b49e17785742fb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a612323e9be85348e9b49e17785742fb4">hasConstraints</a> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00078.html">GaussianFactor</a> &gt; &amp;factors)</td></tr>
<tr class="memdesc:a612323e9be85348e9b49e17785742fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates whether linear factors have any constrained noise models.  <a href="#a612323e9be85348e9b49e17785742fb4"></a><br/></td></tr>
<tr class="memitem:ae52b4fa186f486445363eb80404433e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae52b4fa186f486445363eb80404433e8"></a>
<a class="el" href="a00065.html#a043d04c0f33faa4d411243c45a9b5509">GaussianFactorGraph::EliminationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EliminatePreferCholesky</b> (const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00078.html">GaussianFactor</a> &gt; &amp;factors, size_t nrFrontals)</td></tr>
<tr class="memitem:a25c4a50dd030943548849dd289e5d5c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25c4a50dd030943548849dd289e5d5c8"></a>
<a class="el" href="a00062.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a25c4a50dd030943548849dd289e5d5c8">operator*</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x)</td></tr>
<tr class="memdesc:a25c4a50dd030943548849dd289e5d5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return A*x <br/></td></tr>
<tr class="memitem:abe111950f7be8c5e1e4e17d35f97fd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#abe111950f7be8c5e1e4e17d35f97fd04">multiplyInPlace</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x, <a class="el" href="a00062.html">Errors</a> &amp;e)</td></tr>
<tr class="memdesc:abe111950f7be8c5e1e4e17d35f97fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place version e &lt;- A*x that overwrites e.  <a href="#abe111950f7be8c5e1e4e17d35f97fd04"></a><br/></td></tr>
<tr class="memitem:a798c18aa5033f3b3ab20bb954ed9fcaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a798c18aa5033f3b3ab20bb954ed9fcaf">multiplyInPlace</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x, const Errors::iterator &amp;e)</td></tr>
<tr class="memdesc:a798c18aa5033f3b3ab20bb954ed9fcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place version e &lt;- A*x that takes an iterator.  <a href="#a798c18aa5033f3b3ab20bb954ed9fcaf"></a><br/></td></tr>
<tr class="memitem:a1f292caf56070a8933b3f5192cf4af10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f292caf56070a8933b3f5192cf4af10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a1f292caf56070a8933b3f5192cf4af10">transposeMultiplyAdd</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, double alpha, const <a class="el" href="a00062.html">Errors</a> &amp;e, <a class="el" href="a00210.html">VectorValues</a> &amp;x)</td></tr>
<tr class="memdesc:a1f292caf56070a8933b3f5192cf4af10"><td class="mdescLeft">&#160;</td><td class="mdescRight">x += alpha*A'*e <br/></td></tr>
<tr class="memitem:a2d73af7c695a2f4a1bbd71ad5e183037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a2d73af7c695a2f4a1bbd71ad5e183037">gradient</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x0)</td></tr>
<tr class="memdesc:a2d73af7c695a2f4a1bbd71ad5e183037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} A x - b \right\Vert^2 \), centered around \( x = x_0 \).  <a href="#a2d73af7c695a2f4a1bbd71ad5e183037"></a><br/></td></tr>
<tr class="memitem:ae92de35efe78151f344b66ef5a9db9c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ae92de35efe78151f344b66ef5a9db9c4">gradientAtZero</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, <a class="el" href="a00210.html">VectorValues</a> &amp;g)</td></tr>
<tr class="memdesc:ae92de35efe78151f344b66ef5a9db9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} A x - b \right\Vert^2 \), centered around zero.  <a href="#ae92de35efe78151f344b66ef5a9db9c4"></a><br/></td></tr>
<tr class="memitem:a12cb5d0fce664dc75f4533d26a301ef6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12cb5d0fce664dc75f4533d26a301ef6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>residual</b> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x, <a class="el" href="a00210.html">VectorValues</a> &amp;r)</td></tr>
<tr class="memitem:aaf6edf186c5f2c3628caffadaf3eff10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6edf186c5f2c3628caffadaf3eff10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x, <a class="el" href="a00210.html">VectorValues</a> &amp;r)</td></tr>
<tr class="memitem:a3f3fac773de7b738afc53bd1cc655381"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f3fac773de7b738afc53bd1cc655381"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transposeMultiply</b> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;r, <a class="el" href="a00210.html">VectorValues</a> &amp;x)</td></tr>
<tr class="memitem:a0538887cdf8a9e85f0d94b1f46e67ea9"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="a00062.html">Errors</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a0538887cdf8a9e85f0d94b1f46e67ea9">gaussianErrors_</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x)</td></tr>
<tr class="memdesc:a0538887cdf8a9e85f0d94b1f46e67ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">shared pointer version  <a href="#a0538887cdf8a9e85f0d94b1f46e67ea9"></a><br/></td></tr>
<tr class="memitem:a216cf1995d96ddd9808f8d6c9d2e78d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00062.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a216cf1995d96ddd9808f8d6c9d2e78d2">gaussianErrors</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x)</td></tr>
<tr class="memdesc:a216cf1995d96ddd9808f8d6c9d2e78d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return A*x-b  <a href="#a216cf1995d96ddd9808f8d6c9d2e78d2"></a><br/></td></tr>
<tr class="memitem:ab070ac54003c625d8382e442da850acb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab070ac54003c625d8382e442da850acb"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (const <a class="el" href="a00080.html">GaussianISAM</a> &amp;isam)</td></tr>
<tr class="memitem:a6516ea957c3a22ddf429cefef1fe9486"><td class="memTemplParams" colspan="2">template&lt;class S , class V , class E &gt; </td></tr>
<tr class="memitem:a6516ea957c3a22ddf429cefef1fe9486"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a6516ea957c3a22ddf429cefef1fe9486">conjugateGradients</a> (const S &amp;Ab, V x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters, bool steepest=false)</td></tr>
<tr class="memdesc:a6516ea957c3a22ddf429cefef1fe9486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG) template "System" class S needs gradient(S,v), e=S*v, v=S^e "Vector" class V needs dot(v,v), -v, v+v, s*v "Vector" class E needs dot(v,v)  <a href="#a6516ea957c3a22ddf429cefef1fe9486"></a><br/></td></tr>
<tr class="memitem:a0dffaf102d7e9efcaea199e4cc2e95e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dffaf102d7e9efcaea199e4cc2e95e3"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>steepestDescent</b> (const <a class="el" href="a00194.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memitem:ad2b587fde5d35a27d6c88feb4432e785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2b587fde5d35a27d6c88feb4432e785"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad2b587fde5d35a27d6c88feb4432e785">conjugateGradientDescent</a> (const <a class="el" href="a00194.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:ad2b587fde5d35a27d6c88feb4432e785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), <a class="el" href="a00194.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> version. <br/></td></tr>
<tr class="memitem:aed4b2ca704ddd6530ea70122f883ac88"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aed4b2ca704ddd6530ea70122f883ac88">steepestDescent</a> (const Matrix &amp;A, const Vector &amp;b, const Vector &amp;x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:aed4b2ca704ddd6530ea70122f883ac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience calls using matrices, will create <a class="el" href="a00194.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class internally:  <a href="#aed4b2ca704ddd6530ea70122f883ac88"></a><br/></td></tr>
<tr class="memitem:af55440f741d8b2f706101f7a79ba7111"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af55440f741d8b2f706101f7a79ba7111"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#af55440f741d8b2f706101f7a79ba7111">conjugateGradientDescent</a> (const Matrix &amp;A, const Vector &amp;b, const Vector &amp;x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:af55440f741d8b2f706101f7a79ba7111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), Matrix version. <br/></td></tr>
<tr class="memitem:a81b7af7638d28555c3f404318cc67b22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b7af7638d28555c3f404318cc67b22"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a81b7af7638d28555c3f404318cc67b22">steepestDescent</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a81b7af7638d28555c3f404318cc67b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of steepest gradients, Gaussian <a class="el" href="a00064.html" title="This is the base class for all factor types.">Factor</a> Graph version. <br/></td></tr>
<tr class="memitem:aa84114ad1593684ad739088a2898afdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84114ad1593684ad739088a2898afdb"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa84114ad1593684ad739088a2898afdb">conjugateGradientDescent</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00210.html">VectorValues</a> &amp;x, const <a class="el" href="a00034.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:aa84114ad1593684ad739088a2898afdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), Gaussian <a class="el" href="a00064.html" title="This is the base class for all factor types.">Factor</a> Graph version. <br/></td></tr>
<tr class="memitem:ab942ea2e31cb3ef16f72232628591688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab942ea2e31cb3ef16f72232628591688"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab942ea2e31cb3ef16f72232628591688">gradient</a> (const <a class="el" href="a00194.html">System</a> &amp;system, const Vector &amp;x)</td></tr>
<tr class="memdesc:ab942ea2e31cb3ef16f72232628591688"><td class="mdescLeft">&#160;</td><td class="mdescRight">gradient of objective function 0.5*|Ax-b_|^2 at x = A_'*(Ax-b_) <br/></td></tr>
<tr class="memitem:a9e32569a395ac47377a8d3cc9ff951a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e32569a395ac47377a8d3cc9ff951a0"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9e32569a395ac47377a8d3cc9ff951a0">operator*</a> (const <a class="el" href="a00194.html">System</a> &amp;system, const Vector &amp;x)</td></tr>
<tr class="memdesc:a9e32569a395ac47377a8d3cc9ff951a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator A. <br/></td></tr>
<tr class="memitem:ad96343c4ffa538217d1d694d6d7e645d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96343c4ffa538217d1d694d6d7e645d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad96343c4ffa538217d1d694d6d7e645d">multiplyInPlace</a> (const <a class="el" href="a00194.html">System</a> &amp;system, const Vector &amp;x, Vector &amp;e)</td></tr>
<tr class="memdesc:ad96343c4ffa538217d1d694d6d7e645d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator A in place. <br/></td></tr>
<tr class="memitem:add103f192030842697e388191e90c813"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add103f192030842697e388191e90c813"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#add103f192030842697e388191e90c813">transposeMultiplyAdd</a> (const <a class="el" href="a00194.html">System</a> &amp;system, double alpha, const Vector &amp;e, Vector &amp;x)</td></tr>
<tr class="memdesc:add103f192030842697e388191e90c813"><td class="mdescLeft">&#160;</td><td class="mdescRight">x += alpha* A'*e <br/></td></tr>
<tr class="memitem:a37ca85391e3bc671c71b68bc324296f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ca85391e3bc671c71b68bc324296f0"></a>
GTSAM_EXPORT Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a37ca85391e3bc671c71b68bc324296f0">steepestDescent</a> (const <a class="el" href="a00194.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a00110.html">IterativeOptimizationParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a37ca85391e3bc671c71b68bc324296f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of steepest gradients, <a class="el" href="a00194.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> version. <br/></td></tr>
<tr class="memitem:a8c5e57378be18d816580202bdccf9dd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c5e57378be18d816580202bdccf9dd8"></a>
<a class="el" href="a00115.html#a943f07d46bc01eac1070cd08fc193cc1">KalmanFilter::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8c5e57378be18d816580202bdccf9dd8">solve</a> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;factorGraph, bool useQR)</td></tr>
<tr class="memdesc:a8c5e57378be18d816580202bdccf9dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to solve factor graph and return pointer to root conditional. <br/></td></tr>
<tr class="memitem:a48a2a1d72a3057cdcc97a8499b30af98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48a2a1d72a3057cdcc97a8499b30af98"></a>
<a class="el" href="a00115.html#a943f07d46bc01eac1070cd08fc193cc1">KalmanFilter::State</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fuse</b> (const <a class="el" href="a00115.html#a943f07d46bc01eac1070cd08fc193cc1">KalmanFilter::State</a> &amp;p, <a class="el" href="a00078.html">GaussianFactor</a> *newFactor, bool useQR)</td></tr>
<tr class="memitem:a0a763bc783f6d060558ba1567702e9dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a763bc783f6d060558ba1567702e9dc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>error</b> (const <a class="el" href="a00185.html">SubgraphPreconditioner</a> &amp;sp, const <a class="el" href="a00210.html">VectorValues</a> &amp;y)</td></tr>
<tr class="memitem:ab88c2638dd5b228ef938c2c7c8668385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab88c2638dd5b228ef938c2c7c8668385"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ab88c2638dd5b228ef938c2c7c8668385">gradient</a> (const <a class="el" href="a00185.html">SubgraphPreconditioner</a> &amp;sp, const <a class="el" href="a00210.html">VectorValues</a> &amp;y)</td></tr>
<tr class="memdesc:ab88c2638dd5b228ef938c2c7c8668385"><td class="mdescLeft">&#160;</td><td class="mdescRight">gradient = y + inv(R1')*A2'*(A2*inv(R1)*y-b2bar) <br/></td></tr>
<tr class="memitem:a8b635fb38ce24d4d5ecc7e8d019efaea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b635fb38ce24d4d5ecc7e8d019efaea"></a>
<a class="el" href="a00062.html">Errors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8b635fb38ce24d4d5ecc7e8d019efaea">operator*</a> (const <a class="el" href="a00185.html">SubgraphPreconditioner</a> &amp;sp, const <a class="el" href="a00210.html">VectorValues</a> &amp;y)</td></tr>
<tr class="memdesc:a8b635fb38ce24d4d5ecc7e8d019efaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator A. <br/></td></tr>
<tr class="memitem:a7fb6481c010038f87d8aa8f635303401"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fb6481c010038f87d8aa8f635303401"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7fb6481c010038f87d8aa8f635303401">multiplyInPlace</a> (const <a class="el" href="a00185.html">SubgraphPreconditioner</a> &amp;sp, const <a class="el" href="a00210.html">VectorValues</a> &amp;y, <a class="el" href="a00062.html">Errors</a> &amp;e)</td></tr>
<tr class="memdesc:a7fb6481c010038f87d8aa8f635303401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator A in place: needs e allocated already. <br/></td></tr>
<tr class="memitem:a0f826c76568616033f8d9152b64e3703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f826c76568616033f8d9152b64e3703"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a0f826c76568616033f8d9152b64e3703">operator^</a> (const <a class="el" href="a00185.html">SubgraphPreconditioner</a> &amp;sp, const <a class="el" href="a00062.html">Errors</a> &amp;e)</td></tr>
<tr class="memdesc:a0f826c76568616033f8d9152b64e3703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator A'. <br/></td></tr>
<tr class="memitem:a8a65ce96c1581dac3aae8af1b4f72e1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a65ce96c1581dac3aae8af1b4f72e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a8a65ce96c1581dac3aae8af1b4f72e1e">transposeMultiplyAdd</a> (const <a class="el" href="a00185.html">SubgraphPreconditioner</a> &amp;sp, double alpha, const <a class="el" href="a00062.html">Errors</a> &amp;e, <a class="el" href="a00210.html">VectorValues</a> &amp;y)</td></tr>
<tr class="memdesc:a8a65ce96c1581dac3aae8af1b4f72e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add A'<em>e to y y += alpha*A'</em>[e1;e2] = [alpha*e1; alpha*inv(R1')*A2'*e2]. <br/></td></tr>
<tr class="memitem:a58687cb28d2ac42f2ca427a44ad50b79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58687cb28d2ac42f2ca427a44ad50b79"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckRelinearizationRecursiveDouble</b> (<a class="el" href="a00069.html">FastSet</a>&lt; <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> &gt; &amp;relinKeys, double threshold, const <a class="el" href="a00210.html">VectorValues</a> &amp;<a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>, const ISAM2Clique::shared_ptr &amp;clique)</td></tr>
<tr class="memitem:aee1d89ac72c00a07b44d9be07765260d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee1d89ac72c00a07b44d9be07765260d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckRelinearizationRecursiveMap</b> (<a class="el" href="a00069.html">FastSet</a>&lt; <a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a> &gt; &amp;relinKeys, const <a class="el" href="a00068.html">FastMap</a>&lt; char, Vector &gt; &amp;thresholds, const <a class="el" href="a00210.html">VectorValues</a> &amp;<a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>, const <a class="el" href="a00151.html">Ordering</a> &amp;ordering, const ISAM2Clique::shared_ptr &amp;clique)</td></tr>
<tr class="memitem:a49dde188b771621fb28d8d8db471df96"><td class="memTemplParams" colspan="2">template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:a49dde188b771621fb28d8d8db471df96"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a49dde188b771621fb28d8d8db471df96">optimizeWildfire</a> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;root, double threshold, const std::vector&lt; bool &gt; &amp;replaced, <a class="el" href="a00210.html">VectorValues</a> &amp;<a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>)</td></tr>
<tr class="memdesc:a49dde188b771621fb28d8d8db471df96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the <a class="el" href="a00010.html">BayesTree</a>, starting from the root.  <a href="#a49dde188b771621fb28d8d8db471df96"></a><br/></td></tr>
<tr class="memitem:a0050aefd0e18de39fa002753c7719de9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0050aefd0e18de39fa002753c7719de9"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:a0050aefd0e18de39fa002753c7719de9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optimizeWildfireNonRecursive</b> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;root, double threshold, const std::vector&lt; bool &gt; &amp;keys, <a class="el" href="a00210.html">VectorValues</a> &amp;<a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>)</td></tr>
<tr class="memitem:a710993cf2d56652448517817943ad10f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a710993cf2d56652448517817943ad10f"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:a710993cf2d56652448517817943ad10f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nnz_internal</b> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;clique, int &amp;result)</td></tr>
<tr class="memitem:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca63ccfbd14352eade58fd2a2ec6b5e4"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#aca63ccfbd14352eade58fd2a2ec6b5e4">calculate_nnz</a> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;clique)</td></tr>
<tr class="memdesc:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the number of non-zero entries for the tree starting at clique (use root for complete matrix) <br/></td></tr>
<tr class="memitem:a3625e4794eaa3c2adeb8fcf68ceb33c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3625e4794eaa3c2adeb8fcf68ceb33c5"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a3625e4794eaa3c2adeb8fcf68ceb33c5">optimize</a> (const <a class="el" href="a00102.html">ISAM2</a> &amp;isam)</td></tr>
<tr class="memdesc:a3625e4794eaa3c2adeb8fcf68ceb33c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the linear delta for the <a class="el" href="a00102.html">ISAM2</a> object, unpermuted the delta returned by <a class="el" href="a00102.html#afd9b2b9fedb892b1ad2e693fc3ff2cb4" title="Access the current delta, computed during the last call to update.">ISAM2::getDelta()</a> <br/></td></tr>
<tr class="memitem:a75b5046916273509726fab14f98a4707"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75b5046916273509726fab14f98a4707"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a75b5046916273509726fab14f98a4707">optimizeInPlace</a> (const <a class="el" href="a00102.html">ISAM2</a> &amp;isam, <a class="el" href="a00210.html">VectorValues</a> &amp;<a class="el" href="a00243.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>)</td></tr>
<tr class="memdesc:a75b5046916273509726fab14f98a4707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the linear delta for the <a class="el" href="a00102.html">ISAM2</a> object, unpermuted the delta returned by <a class="el" href="a00102.html#afd9b2b9fedb892b1ad2e693fc3ff2cb4" title="Access the current delta, computed during the last call to update.">ISAM2::getDelta()</a> <br/></td></tr>
<tr class="memitem:a87e0060b201a8f1aeb004c8347b34023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a87e0060b201a8f1aeb004c8347b34023">optimizeGradientSearch</a> (const <a class="el" href="a00102.html">ISAM2</a> &amp;isam)</td></tr>
<tr class="memdesc:a87e0060b201a8f1aeb004c8347b34023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize along the gradient direction, with a closed-form computation to perform the line search.  <a href="#a87e0060b201a8f1aeb004c8347b34023"></a><br/></td></tr>
<tr class="memitem:a9eab4247c077bc31ce459956f5bd937f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eab4247c077bc31ce459956f5bd937f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9eab4247c077bc31ce459956f5bd937f">optimizeGradientSearchInPlace</a> (const <a class="el" href="a00102.html">ISAM2</a> &amp;isam, <a class="el" href="a00210.html">VectorValues</a> &amp;grad)</td></tr>
<tr class="memdesc:a9eab4247c077bc31ce459956f5bd937f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place version of optimizeGradientSearch requiring pre-allocated <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> <code>x</code>. <br/></td></tr>
<tr class="memitem:a056ccc2824b7b82a1199d0c762e06cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a056ccc2824b7b82a1199d0c762e06cf8">gradient</a> (const <a class="el" href="a00102.html">ISAM2</a> &amp;bayesTree, const <a class="el" href="a00210.html">VectorValues</a> &amp;x0)</td></tr>
<tr class="memdesc:a056ccc2824b7b82a1199d0c762e06cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \).  <a href="#a056ccc2824b7b82a1199d0c762e06cf8"></a><br/></td></tr>
<tr class="memitem:a9fe8b9212225e1dd3dfaf9163a277aae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9fe8b9212225e1dd3dfaf9163a277aae">gradientAtZero</a> (const <a class="el" href="a00102.html">ISAM2</a> &amp;bayesTree, <a class="el" href="a00210.html">VectorValues</a> &amp;g)</td></tr>
<tr class="memdesc:a9fe8b9212225e1dd3dfaf9163a277aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero.  <a href="#a9fe8b9212225e1dd3dfaf9163a277aae"></a><br/></td></tr>
<tr class="memitem:a6435f73056db87524ffa53c2f7e8c72a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6435f73056db87524ffa53c2f7e8c72a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_defaultKeyFormatter</b> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memitem:a9a428d3edc3f9fa4d5608608abb95df9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a428d3edc3f9fa4d5608608abb95df9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_multirobotKeyFormatter</b> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">gtsam::Key</a> key)</td></tr>
<tr class="memitem:aa8c961d19ef3283162aea0427c3e229d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8c961d19ef3283162aea0427c3e229d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aa8c961d19ef3283162aea0427c3e229d">printKeySet</a> (const <a class="el" href="a00069.html">KeySet</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a00243.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:aa8c961d19ef3283162aea0427c3e229d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br/></td></tr>
<tr class="memitem:ae9a7dceb0a85c356062b55f6939b1419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ae9a7dceb0a85c356062b55f6939b1419">mrsymbol</a> (unsigned char c, unsigned char label, size_t j)</td></tr>
<tr class="memdesc:ae9a7dceb0a85c356062b55f6939b1419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol key from a character, label and index, i.e.  <a href="#ae9a7dceb0a85c356062b55f6939b1419"></a><br/></td></tr>
<tr class="memitem:a37995b0d0610e5fb29c6bd0715151d67"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a37995b0d0610e5fb29c6bd0715151d67">mrsymbolChr</a> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a37995b0d0610e5fb29c6bd0715151d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character portion of a symbol key.  <a href="#a37995b0d0610e5fb29c6bd0715151d67"></a><br/></td></tr>
<tr class="memitem:a4e4c133c4fd0d9d73593f601be2248a6"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a4e4c133c4fd0d9d73593f601be2248a6">mrsymbolLabel</a> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a4e4c133c4fd0d9d73593f601be2248a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the label portion of a symbol key.  <a href="#a4e4c133c4fd0d9d73593f601be2248a6"></a><br/></td></tr>
<tr class="memitem:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a4adc1bb606fa4a14d5dbd246f95cecd3">mrsymbolIndex</a> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index portion of a symbol key.  <a href="#a4adc1bb606fa4a14d5dbd246f95cecd3"></a><br/></td></tr>
<tr class="memitem:ad97791f7dc778c4aa4d913a3e119107b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad97791f7dc778c4aa4d913a3e119107b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gradientInPlace</b> (const <a class="el" href="a00145.html">NonlinearFactorGraph</a> &amp;nfg, const <a class="el" href="a00202.html">Values</a> &amp;values, const <a class="el" href="a00151.html">Ordering</a> &amp;ordering, <a class="el" href="a00210.html">VectorValues</a> &amp;g)</td></tr>
<tr class="memitem:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ceb9e5a5e864b96c529db67f55a873b"></a>
template&lt;class S , class V , class W &gt; </td></tr>
<tr class="memitem:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a0ceb9e5a5e864b96c529db67f55a873b">lineSearch</a> (const S &amp;system, const V currentValues, const W &amp;<a class="el" href="a00243.html#a3f4fb4f157ae7441db3c88b2379dfde3">gradient</a>)</td></tr>
<tr class="memdesc:a0ceb9e5a5e864b96c529db67f55a873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the golden-section line search algorithm. <br/></td></tr>
<tr class="memitem:a84fe4789f88b33c6ab5119b1e2d007e1"><td class="memTemplParams" colspan="2">template&lt;class S , class V &gt; </td></tr>
<tr class="memitem:a84fe4789f88b33c6ab5119b1e2d007e1"><td class="memTemplItemLeft" align="right" valign="top">boost::tuple&lt; V, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a84fe4789f88b33c6ab5119b1e2d007e1">nonlinearConjugateGradient</a> (const S &amp;system, const V &amp;initial, const <a class="el" href="a00148.html">NonlinearOptimizerParams</a> &amp;params, const bool singleIteration, const bool gradientDescent=false)</td></tr>
<tr class="memdesc:a84fe4789f88b33c6ab5119b1e2d007e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the nonlinear conjugate gradient method using the Polak-Ribieve formula suggested in <a href="http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method">http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>.  <a href="#a84fe4789f88b33c6ab5119b1e2d007e1"></a><br/></td></tr>
<tr class="memitem:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a544e7c98a6f6224e5cbcd71f4646c52b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a544e7c98a6f6224e5cbcd71f4646c52b">compare</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template default compare function that assumes a testable T. <br/></td></tr>
<tr class="memitem:a41944afbc77eee81f8454f382ee639d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41944afbc77eee81f8454f382ee639d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a41944afbc77eee81f8454f382ee639d4">checkConvergence</a> (double relativeErrorTreshold, double absoluteErrorTreshold, double errorThreshold, double currentError, double newError, <a class="el" href="a00148.html#a2b085d375ec6effa42e3deaaeab98694">NonlinearOptimizerParams::Verbosity</a> verbosity)</td></tr>
<tr class="memdesc:a41944afbc77eee81f8454f382ee639d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the relative error decrease is less than relativeErrorTreshold, the absolute error decrease is less than absoluteErrorTreshold, <em>or</em> the error itself is less than errorThreshold. <br/></td></tr>
<tr class="memitem:afb9ee3fe3cb8c697a9cd90919cb61e1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb9ee3fe3cb8c697a9cd90919cb61e1c"></a>
<a class="el" href="a00210.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>solveGaussianFactorGraph</b> (const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;gfg, const <a class="el" href="a00188.html">SuccessiveLinearizationParams</a> &amp;params)</td></tr>
<tr class="memitem:abc653ffcec5154f355877f6a802b8b7e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00079.html">GaussianFactorGraph</a>, <br class="typebreak"/>
<a class="el" href="a00151.html">Ordering</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#abc653ffcec5154f355877f6a802b8b7e">summarize</a> (const <a class="el" href="a00145.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a00202.html">Values</a> &amp;values, const <a class="el" href="a00069.html">KeySet</a> &amp;saved_keys, <a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45a">SummarizationMode</a> mode=PARTIAL_QR)</td></tr>
<tr class="memdesc:abc653ffcec5154f355877f6a802b8b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarization function to remove a subset of variables from a system with the sequential solver.  <a href="#abc653ffcec5154f355877f6a802b8b7e"></a><br/></td></tr>
<tr class="memitem:afbdaa652f50405a7ae95d28b55aeb55b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00145.html">NonlinearFactorGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#afbdaa652f50405a7ae95d28b55aeb55b">summarizeAsNonlinearContainer</a> (const <a class="el" href="a00145.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a00202.html">Values</a> &amp;values, const <a class="el" href="a00069.html">KeySet</a> &amp;saved_keys, <a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45a">SummarizationMode</a> mode=PARTIAL_QR)</td></tr>
<tr class="memdesc:afbdaa652f50405a7ae95d28b55aeb55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the same summarization technique used in <a class="el" href="a00243.html#abc653ffcec5154f355877f6a802b8b7e" title="Summarization function to remove a subset of variables from a system with the sequential solver...">summarize()</a>, but returns the result as a <a class="el" href="a00145.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> comprised of LinearContainerFactors.  <a href="#afbdaa652f50405a7ae95d28b55aeb55b"></a><br/></td></tr>
<tr class="memitem:a7cd266db68d8146af3b9b1630d4b700b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a7cd266db68d8146af3b9b1630d4b700b">symbol</a> (unsigned char c, size_t j)</td></tr>
<tr class="memdesc:a7cd266db68d8146af3b9b1630d4b700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol key from a character and index, i.e.  <a href="#a7cd266db68d8146af3b9b1630d4b700b"></a><br/></td></tr>
<tr class="memitem:a9ca9499e881d22361b4833c2854d941f"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a9ca9499e881d22361b4833c2854d941f">symbolChr</a> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a9ca9499e881d22361b4833c2854d941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character portion of a symbol key.  <a href="#a9ca9499e881d22361b4833c2854d941f"></a><br/></td></tr>
<tr class="memitem:a901c06d89d5c4ba46d926a86b307f271"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a901c06d89d5c4ba46d926a86b307f271">symbolIndex</a> (<a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a901c06d89d5c4ba46d926a86b307f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index portion of a symbol key.  <a href="#a901c06d89d5c4ba46d926a86b307f271"></a><br/></td></tr>
<tr class="memitem:aef971b2c69845e4fcce707306703c7b8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#aef971b2c69845e4fcce707306703c7b8">findExampleDataFile</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aef971b2c69845e4fcce707306703c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the full path to an example dataset distributed with gtsam.  <a href="#aef971b2c69845e4fcce707306703c7b8"></a><br/></td></tr>
<tr class="memitem:afc80188d4f1bbe3f7fc78537e175024a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc80188d4f1bbe3f7fc78537e175024a"></a>
pair<br class="typebreak"/>
&lt; NonlinearFactorGraph::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load2D</b> (pair&lt; string, boost::optional&lt; noiseModel::Diagonal::shared_ptr &gt; &gt; dataset, int maxID, bool addNoise, bool smart)</td></tr>
<tr class="memitem:acf65255bf7b83114510b410747afab53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf65255bf7b83114510b410747afab53"></a>
pair<br class="typebreak"/>
&lt; NonlinearFactorGraph::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load2D</b> (const string &amp;filename, boost::optional&lt; noiseModel::Diagonal::shared_ptr &gt; model, int maxID, bool addNoise, bool smart)</td></tr>
<tr class="memitem:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfe516bc2d9ca4cc4530dd3b8460ce3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#acfe516bc2d9ca4cc4530dd3b8460ce3d">save2D</a> (const <a class="el" href="a00145.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a00202.html">Values</a> &amp;config, const noiseModel::Diagonal::shared_ptr model, const std::string &amp;filename)</td></tr>
<tr class="memdesc:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">save 2d graph <br/></td></tr>
<tr class="memitem:a91606476a4bb8cf6b890546cae31a612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91606476a4bb8cf6b890546cae31a612"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a91606476a4bb8cf6b890546cae31a612">load3D</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a91606476a4bb8cf6b890546cae31a612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 3D Graph. <br/></td></tr>
<tr class="memitem:a09839b410e7b4c7cd0263d780e3bc828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09839b410e7b4c7cd0263d780e3bc828"></a>
pair<br class="typebreak"/>
&lt; NonlinearFactorGraph::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load2D_robust</b> (const string &amp;filename, noiseModel::Base::shared_ptr &amp;model, int maxID)</td></tr>
<tr class="memitem:a1dcfc59dfe82c86e4f23381b4092acea"><td class="memItemLeft" align="right" valign="top">GTSAM_EXPORT std::pair<br class="typebreak"/>
&lt; NonlinearFactorGraph::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a1dcfc59dfe82c86e4f23381b4092acea">load2D</a> (std::pair&lt; std::string, boost::optional&lt; noiseModel::Diagonal::shared_ptr &gt; &gt; dataset, int maxID=0, bool addNoise=false, bool smart=true)</td></tr>
<tr class="memdesc:a1dcfc59dfe82c86e4f23381b4092acea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 2D Graph.  <a href="#a1dcfc59dfe82c86e4f23381b4092acea"></a><br/></td></tr>
<tr class="memitem:a73b0a64ce60fcad87492dfce610e3d9e"><td class="memItemLeft" align="right" valign="top">GTSAM_EXPORT std::pair<br class="typebreak"/>
&lt; NonlinearFactorGraph::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#a73b0a64ce60fcad87492dfce610e3d9e">load2D</a> (const std::string &amp;filename, boost::optional&lt; gtsam::SharedDiagonal &gt; model=boost::optional&lt; noiseModel::Diagonal::shared_ptr &gt;(), int maxID=0, bool addNoise=false, bool smart=true)</td></tr>
<tr class="memdesc:a73b0a64ce60fcad87492dfce610e3d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 2D Graph.  <a href="#a73b0a64ce60fcad87492dfce610e3d9e"></a><br/></td></tr>
<tr class="memitem:a80d640f59e5d39a1165069a3841cc5d1"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a80d640f59e5d39a1165069a3841cc5d1"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00243.html#a80d640f59e5d39a1165069a3841cc5d1">transform_point</a> (const T &amp;<a class="el" href="a00243.html#aa2e36d7ab63000feddaeb61bbfcf2db1">trans</a>, const P &amp;global, boost::optional&lt; Matrix &amp; &gt; Dtrans, boost::optional&lt; Matrix &amp; &gt; Dglobal)</td></tr>
<tr class="memdesc:a80d640f59e5d39a1165069a3841cc5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform function that must be specialized specific domains.  <a href="#a80d640f59e5d39a1165069a3841cc5d1"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adf88da16ba218bfa58acd963ca647bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf88da16ba218bfa58acd963ca647bc3"></a>
GTSAM_EXPORT typedef <a class="el" href="a00010.html">BayesTree</a><br class="typebreak"/>
&lt; <a class="el" href="a00076.html">GaussianConditional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#adf88da16ba218bfa58acd963ca647bc3">GaussianBayesTree</a></td></tr>
<tr class="memdesc:adf88da16ba218bfa58acd963ca647bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes Tree representing a Gaussian density. <br/></td></tr>
<tr class="memitem:ab8b4f36c2129e113c3652c32d611fecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b4f36c2129e113c3652c32d611fecb"></a>
GTSAM_EXPORT <a class="el" href="a00068.html">FastMap</a><br class="typebreak"/>
&lt; std::string, <br class="typebreak"/>
<a class="el" href="a00206.html">ValueWithDefault</a>&lt; bool, false &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>debugFlags</b></td></tr>
<tr class="memitem:ad5602eb85d05df6cba60e47eebbd3636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5602eb85d05df6cba60e47eebbd3636"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html#ad5602eb85d05df6cba60e47eebbd3636">logSqrt2PI</a> = log(std::sqrt(2.0 * M_PI))</td></tr>
<tr class="memdesc:ad5602eb85d05df6cba60e47eebbd3636"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant needed below <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Global functions in a separate testing namespace. </p>
<p>Matrix is a typedef in the gtsam namespace TODO: make a version to work with matlab wrapping we use the default &lt; double,col_major,unbounded_array&lt;double&gt; &gt;</p>
<p>These should not be used outside of tests, as they are just remappings of the original functions. We use these to avoid needing to do too much boost::bind magic or writing a bunch of separate proxy functions.</p>
<p>Don't expect all classes to work for all of these functions. </p>
</div><h2>Typedef Documentation</h2>
<a class="anchor" id="acd76f1ddc9222a483adcca0335556277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;std::string(<a class="el" href="a00243.html#ab6d32a7175826a8984dc554fa0025a49">Index</a>)&gt; <a class="el" href="a00243.html#acd76f1ddc9222a483adcca0335556277">gtsam::IndexFormatter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to convert indices to strings, for example by translating back to a nonlinear key and then to a <a class="el" href="a00189.html" title="Character and index key used in VectorValues, GaussianFactorGraph, GaussianFactor, etc.">Symbol</a>. </p>

</div>
</div>
<a class="anchor" id="a59e2c1120d40da6062c03ab31e869065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Quaternion&lt;double, Eigen::DontAlign&gt; <a class="el" href="a00243.html#a59e2c1120d40da6062c03ab31e869065">gtsam::Quaternion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to an Eigen Quaternion&lt;double&gt;, we disable alignment because geometry objects are stored in boost pool allocators, in <a class="el" href="a00202.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> containers, and and these pool allocators do not support alignment. </p>

</div>
</div>
<a class="anchor" id="ab6e5a4884342656e0837ef07008ec03f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef noiseModel::Base::shared_ptr <a class="el" href="a00243.html#ab6e5a4884342656e0837ef07008ec03f">gtsam::SharedNoiseModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note, deliberately not in <a class="el" href="a00465.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace. </p>
<p>Deprecated. Only for compatibility with previous version. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a166d6cd0600305853a0d3aebad70a45a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00243.html#a166d6cd0600305853a0d3aebad70a45a">gtsam::SummarizationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a166d6cd0600305853a0d3aebad70a45aacf119d9acb3827e7ee3eea1be23f3a82"></a>PARTIAL_CHOLESKY</em>&nbsp;</td><td>
<p>Uses QR solver to eliminate, does not require fully constrained system. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a166d6cd0600305853a0d3aebad70a45aa82cb5313411a3fe8ce502eff83ebda06"></a>SEQUENTIAL_QR</em>&nbsp;</td><td>
<p>Uses Cholesky solver, does not require fully constrained system. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a166d6cd0600305853a0d3aebad70a45aae002bd076d926799d388fe13e6c05d76"></a>SEQUENTIAL_CHOLESKY</em>&nbsp;</td><td>
<p>Uses QR to compute full joint graph (needs fully constrained system) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a5ba06101b45d9f2647608cbf4e3b35aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::abs </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Absolute values of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[abs(a(i))] </dd></dl>

</div>
</div>
<a class="anchor" id="add6d6575582314cc9b5dbdbe2a86374d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const boost::optional&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::optional&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparisons for boost.optional objects that checks whether objects exist before comparing their values. </p>
<p>First version allows for both to be boost::none, but the second, with expected given rather than optional</p>
<p>Concept requirement: V is testable </p>

</div>
</div>
<a class="anchor" id="a0931276a9406dfc1bcff6d265704ee39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of assert_equals to work with vectors. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00481.html#_deprecated000001">Deprecated:</a></b></dt><dd>: use container equals instead </dd></dl>

</div>
</div>
<a class="anchor" id="a9f3ee662d25ffb8c04b4e35c4b02e90b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="ac3cf8e8e70cd696d9c789c31bc1e89a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca3db47b15350977c1f03c5560ab332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_inequal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not the same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a30a89a0147943428129e2cb3683988be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V1 , class V2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::axpy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BLAS Level 1 axpy: y &lt;- alpha*x + y. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00481.html#_deprecated000003">Deprecated:</a></b></dt><dd>: use operators instead </dd></dl>

</div>
</div>
<a class="anchor" id="a0d998e1b770c9864946ddb031b1c4522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteLower </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute L*x=b </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>an lower triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of L*x=b </dd></dl>

</div>
</div>
<a class="anchor" id="ac38b470a3484438d87f33b5148484fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::backSubstituteTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>gx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose Backsubstitute gy=inv(L)*gx by solving L*gy=gx. </p>
<p>gy=inv(R'*inv(Sigma))*gx gz'*R'=gx', gy = gz.*sigmas </p>

</div>
</div>
<a class="anchor" id="a6c4876cbe85d5651a52eda0e97c60f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteUpper </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute U*x=b </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>an upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of U*x=b </dd></dl>

</div>
</div>
<a class="anchor" id="a8b0bf332d52b333dab2b20d763c8925b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteUpper </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute x'*U=b' </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>an upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of x'*U=b' </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec32e8dafe1d25ab11de3d693c1b5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create basis vector of dimension n, with one in spot i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">i</td><td>index of the one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basis vector </dd></dl>

</div>
</div>
<a class="anchor" id="adbd55c711e6ceee791b595558eb3ec8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::BCH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Three term approximation of the Baker�Campbell�Hausdorff formula In non-commutative Lie groups, when composing exp(Z) = exp(X)exp(Y) it is not true that Z = X+Y. </p>
<p>Instead, Z can be calculated using the BCH formula: Z = X + Y + [X,Y]/2 + [X-Y,[X,Y]]/12 - [Y,[X,[X,Y]]]/24 <a href="http://en.wikipedia.org/wiki/Baker">http://en.wikipedia.org/wiki/Baker</a>�Campbell�Hausdorff_formulaAGC: bracket() only appears in <a class="el" href="a00175.html">Rot3</a> tests, should this be used elsewhere? </p>

</div>
</div>
<a class="anchor" id="a473aea76af7b0cbec8f26e6abf1ed87e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::between_default </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These core global functions can be specialized by new Lie types for better performance. </p>
<p>Compute l0 s.t. l2=l1*l0 </p>

</div>
</div>
<a class="anchor" id="a35831074a7aab15d463acddc7767bfe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00005.html">Assignment</a>&lt;L&gt; &gt; gtsam::cartesianProduct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; L, size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Cartesian product consisting all possible configurations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>list of keys (label,cardinality) pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector list of all possible value assignments</dd></dl>
<p>This function returns a vector of <a class="el" href="a00005.html" title="An assignment from labels to value index (size_t).">Assignment</a> values for all possible (Cartesian product) configurations of set of Keys which are nothing but (Label,cardinality) pairs. This function should NOT be called for more than a small number of variables and cardinalities. E.g. For 6 variables with each having cardinalities 4, we get 4096 possible configurations!! </p>

</div>
</div>
<a class="anchor" id="aba542e2cd85f08b76f80a0871a4ea713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::cholesky_inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the inverse of a S.P.D. </p>
<p>matrix. Inversion is done via Cholesky decomposition. </p>

</div>
</div>
<a class="anchor" id="a747683f736c50bca16b3aab0e95b1b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; size_t, bool &gt; gtsam::choleskyCareful </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>ATA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Careful" Cholesky computes the positive square-root of a positive symmetric semi-definite matrix (i.e. </p>
<p>that may be rank-deficient). Unlike standard Cholesky, the square-root factor may have all-zero rows for free variables.</p>
<p>Additionally, this function returns the index of the row after the last non-zero row in the computed factor, so that it may be truncated to an upper-trapazoidal matrix.</p>
<p>The second element of the return value is <code>true</code> if the matrix was factored successfully, or <code>false</code> if it was non-positive-semidefinite (i.e. indefinite or negative-(semi-)definite.</p>
<p>Note that this returned index is the rank of the matrix if and only if all of the zero-rows of the factor occur after any non-zero rows. This is (always?) the case during elimination of a fully-constrained least-squares problem.</p>
<p>The optional order argument specifies the size of the square upper-left submatrix to operate on, ignoring the rest of the matrix. </p>

</div>
</div>
<a class="anchor" id="a1eb8c69f6e0b90ac2dec4287ee8fcb0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::choleskyPartial </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>ABC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFrontal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial Cholesky computes a factor [R S such that [R' 0 [R S = [A B 0 L] S' I] 0 L] B' C]. </p>
<p>The input to this function is the matrix ABC = [A B], and the parameter [B' C] nFrontal determines the split between A, B, and C, with A being of size nFrontal x nFrontal.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the decomposition is successful, <code>false</code> if <code>A</code> was not positive-definite. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8b524ba6c9aed0d21a020999c9b5d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::collect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const Matrix * &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a matrix by concatenating Given a set of matrices: A1, A2, A3... </p>
<p>If all matrices have the same size, specifying single matrix dimensions will avoid the lookup of dimensions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>is a vector of matrices in the order to be collected </td></tr>
    <tr><td class="paramname">m</td><td>is the number of rows of a single matrix </td></tr>
    <tr><td class="paramname">n</td><td>is the number of columns of a single matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined matrix [A1 A2 A3] </dd></dl>

</div>
</div>
<a class="anchor" id="a559dba69e2854eb66e34222f60f55722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MATRIX::ConstColXpr gtsam::column </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a column view from a matrix that avoids a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to extract column from </td></tr>
    <tr><td class="paramname">j</td><td>index of the column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const view of the matrix </dd></dl>

</div>
</div>
<a class="anchor" id="aadd9c566c2b0b790e2dbcddeaab28877"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FACTORGRAPH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FACTORGRAPH gtsam::combine </td>
          <td>(</td>
          <td class="paramtype">const FACTORGRAPH &amp;&#160;</td>
          <td class="paramname"><em>fg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FACTORGRAPH &amp;&#160;</td>
          <td class="paramname"><em>fg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>static function that combines two factor graphs </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg1</td><td>Linear factor graph </td></tr>
    <tr><td class="paramname">fg2</td><td>Linear factor graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new combined factor graph </dd></dl>

</div>
</div>
<a class="anchor" id="ab7e6b80f69dbd7d1457d9dc5f45ebc17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DERIVEDFACTOR , class KEY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DERIVEDFACTOR::shared_ptr gtsam::Combine </td>
          <td>(</td>
          <td class="paramtype">const FactorGraph&lt; DERIVEDFACTOR &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FastMap&lt; KEY, std::vector&lt; KEY &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>variableSlots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a combined joint factor (new style for <a class="el" href="a00059.html" title="An elimination tree is a data structure used intermediately during elimination.">EliminationTree</a>). </p>

</div>
</div>
<a class="anchor" id="a5781266d49d769387b952e51d26b5d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00099.html#a9dfa70fd9d54fe62a5898102a911e542">IndexFactor::shared_ptr</a> gtsam::CombineSymbolic </td>
          <td>(</td>
          <td class="paramtype">const FactorGraph&lt; IndexFactor &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FastMap&lt; Index, std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>variableSlots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a combined joint factor (new style for <a class="el" href="a00059.html" title="An elimination tree is a data structure used intermediately during elimination.">EliminationTree</a>). </p>

</div>
</div>
<a class="anchor" id="a6516ea957c3a22ddf429cefef1fe9486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V gtsam::conjugateGradients </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>Ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConjugateGradientParameters &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>steepest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method of conjugate gradients (CG) template "System" class S needs gradient(S,v), e=S*v, v=S^e "Vector" class V needs dot(v,v), -v, v+v, s*v "Vector" class E needs dot(v,v) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ab,the</td><td>"system" that needs to be solved, examples below </td></tr>
    <tr><td class="paramname">x</td><td>is the initial estimate </td></tr>
    <tr><td class="paramname">steepest</td><td>flag, if true does steepest descent, not CG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2a0ba4a7a13e0f4c781fa9de3e5689e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::delta </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create basis vector of dimension n, with a constant in spot i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">i</td><td>index of the one </td></tr>
    <tr><td class="paramname">value</td><td>is the value to insert into the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>delta vector </dd></dl>

</div>
</div>
<a class="anchor" id="afb635013ae91ee448a08c03a61528f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::determinant </td>
          <td>(</td>
          <td class="paramtype">const GaussianBayesTree &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a GassianBayesTree A GassianBayesTree is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements. </p>
<p>Instead of actually multiplying we add the logarithms of the diagonal elements and take the exponent at the end because this is more numerically stable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesTree</td><td>The input GassianBayesTree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant </dd></dl>

</div>
</div>
<a class="anchor" id="a437b00f8d2f91de1e7c9646a1e30c697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bayesNet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the determinant of a GassianBayesNet A GaussianBayesNet is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements. </p>
<p>Instead of actually multiplying we add the logarithms of the diagonal elements and take the exponent at the end because this is more numerically stable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesNet</td><td>The input GaussianBayesNet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c65f1a69009a306b6a5f9ef31dcee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::tuple&lt; int, double, Vector &gt; gtsam::DLT </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct linear transform algorithm that calls svd to find a vector v that minimizes the algebraic error A*v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>of size m*n, where m&gt;=n (pad with zero rows if not!) Returns rank of A, minimum error (singular value), and corresponding eigenvector (column of V, with A=U*S*V') </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0d4fbafe5819f4617da45c107b3e616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::ediv </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)/b(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="a14844c96706dc362917e0d5e76d65fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::ediv_ </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division, but 0/0 = 0, not inf </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)/b(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="a98334f29148f20bd7f7300f2b48d76bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; boost::shared_ptr&lt; <a class="el" href="a00098.html">IndexConditional</a> &gt;, boost::shared_ptr&lt; <a class="el" href="a00099.html">IndexFactor</a> &gt; &gt; gtsam::EliminateSymbolic </td>
          <td>(</td>
          <td class="paramtype">const FactorGraph&lt; IndexFactor &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrFrontals</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CombineAndEliminate provides symbolic elimination. </p>
<p>Combine and eliminate can also be called separately, but for this and derived classes calling them separately generally does extra work. </p>

</div>
</div>
<a class="anchor" id="ab08665ce2fa3fdc3f7ff6d87b26452cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::emul </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)*b(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="a6c974066d393d86d744e9d387f0d3f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::esqrt </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise sqrt of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[sqrt(a(i))] </dd></dl>

</div>
</div>
<a class="anchor" id="a3041816208c79ef76d3ef2e0991d90b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::expm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential map given exponential coordinates class T needs a wedge&lt;&gt; function and a constructor from Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>exponential coordinates, vector of size n @ return a T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab15462d8c16813d0a7a5b1f76a2f64b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::expm </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical exponential map, naive approach, not industrial strength !!! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to exponentiate </td></tr>
    <tr><td class="paramname">K</td><td>number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0170df6a1f64df845e4445bdf777742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::expmap_default </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponential map centered at l0, s.t. </p>
<p>exp(t,d) = t*exp(d) </p>

</div>
</div>
<a class="anchor" id="a728f2e626412c19fa789a65eaba41819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::eye </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an identity matrix, with matlab-like syntax. </p>
<p>Note: if assigning a block (created from an Eigen block() function) of a matrix to identity, don't use this function, instead use ".setIdentity(m,n)" to avoid an Eigen error. </p>

</div>
</div>
<a class="anchor" id="ae683ac9fd3c4679ddde00872d37f0975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::eye </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a square identity matrix, with matlab-like syntax. </p>
<p>Note: if assigning a block (created from an Eigen block() function) of a matrix to identity, don't use this function, instead use ".setIdentity(m)" to avoid an Eigen error. </p>

</div>
</div>
<a class="anchor" id="aef971b2c69845e4fcce707306703c7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::string gtsam::findExampleDataFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the full path to an example dataset distributed with gtsam. </p>
<p>The name may be specified with or without a file extension - if no extension is give, this function first looks for the .graph extension, then .txt. We first check the gtsam source tree for the file, followed by the installed example dataset location. Both the source tree and installed locations are obtained from CMake during compilation. </p>
<dl class="section return"><dt>Returns</dt><dd>The full path and filename to the requested dataset. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if no matching file could be found using the search process described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a216cf1995d96ddd9808f8d6c9d2e78d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00062.html">Errors</a> gtsam::gaussianErrors </td>
          <td>(</td>
          <td class="paramtype">const GaussianFactorGraph &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorValues &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return A*x-b </p>
<dl class="todo"><dt><b><a class="el" href="a00480.html#_todo000002">Todo:</a></b></dt><dd>Make this a member function - affects <a class="el" href="a00185.html" title="Subgraph conditioner class, as explained in the RSS 2010 submission.">SubgraphPreconditioner</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0538887cdf8a9e85f0d94b1f46e67ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::shared_ptr&lt; <a class="el" href="a00062.html">Errors</a> &gt; gtsam::gaussianErrors_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shared pointer version </p>
<dl class="todo"><dt><b><a class="el" href="a00480.html#_todo000001">Todo:</a></b></dt><dd>Make this a member function - affects <a class="el" href="a00185.html" title="Subgraph conditioner class, as explained in the RSS 2010 submission.">SubgraphPreconditioner</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7137b3408fcad3c1ebfab25ad42a0d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::gradient </td>
          <td>(</td>
          <td class="paramtype">const GaussianBayesTree &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorValues &amp;&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \). </p>
<p>The gradient is \( R^T(Rx-d) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesTree</td><td>The Gaussian Bayes Tree $(R,d)$ </td></tr>
    <tr><td class="paramname">x0</td><td>The center about which to compute the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3f4fb4f157ae7441db3c88b2379dfde3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bayesNet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \). </p>
<p>The gradient is \( R^T(Rx-d) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesNet</td><td>The Gaussian Bayes net $(R,d)$ </td></tr>
    <tr><td class="paramname">x0</td><td>The center about which to compute the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d73af7c695a2f4a1bbd71ad5e183037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} A x - b \right\Vert^2 \), centered around \( x = x_0 \). </p>
<p>The gradient is \( A^T(Ax-b) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The Jacobian factor graph $(A,b)$ </td></tr>
    <tr><td class="paramname">x0</td><td>The center about which to compute the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a056ccc2824b7b82a1199d0c762e06cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::gradient </td>
          <td>(</td>
          <td class="paramtype">const ISAM2 &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorValues &amp;&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=x_0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around \( x = x_0 \). </p>
<p>The gradient is \( R^T(Rx-d) \). This specialized version is used with <a class="el" href="a00102.html">ISAM2</a>, where each clique stores its gradient contribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesTree</td><td>The Gaussian Bayes Tree $(R,d)$ </td></tr>
    <tr><td class="paramname">x0</td><td>The center about which to compute the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a58124dacabb4587d323f0a098f4832a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::gradientAtZero </td>
          <td>(</td>
          <td class="paramtype">const GaussianBayesTree &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorValues &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero. </p>
<p>The gradient about zero is \( -R^T d \). See also <a class="el" href="a00243.html#a3f4fb4f157ae7441db3c88b2379dfde3" title="Compute the gradient of the energy function, , centered around .">gradient(const GaussianBayesNet&amp;, const VectorValues&amp;)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesTree</td><td>The Gaussian Bayes Tree $(R,d)$ </td></tr>
    <tr><td class="paramname">[output]</td><td>g A <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> to store the gradient, which must be preallocated, see allocateVectorValues </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a02f208f5b83fb8c97c7c92aa392715d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::gradientAtZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bayesNet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero. </p>
<p>The gradient about zero is \( -R^T d \). See also <a class="el" href="a00243.html#a3f4fb4f157ae7441db3c88b2379dfde3" title="Compute the gradient of the energy function, , centered around .">gradient(const GaussianBayesNet&amp;, const VectorValues&amp;)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesNet</td><td>The Gaussian Bayes net $(R,d)$ </td></tr>
    <tr><td class="paramname">[output]</td><td>g A <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> to store the gradient, which must be preallocated, see allocateVectorValues </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae92de35efe78151f344b66ef5a9db9c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::gradientAtZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} A x - b \right\Vert^2 \), centered around zero. </p>
<p>The gradient is \( A^T(Ax-b) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The Jacobian factor graph $(A,b)$ </td></tr>
    <tr><td class="paramname">[output]</td><td>g A <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> to store the gradient, which must be preallocated, see allocateVectorValues </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe8b9212225e1dd3dfaf9163a277aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::gradientAtZero </td>
          <td>(</td>
          <td class="paramtype">const ISAM2 &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorValues &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the energy function, \( \nabla_{x=0} \left\Vert \Sigma^{-1} R x - d \right\Vert^2 \), centered around zero. </p>
<p>The gradient about zero is \( -R^T d \). See also <a class="el" href="a00243.html#a3f4fb4f157ae7441db3c88b2379dfde3" title="Compute the gradient of the energy function, , centered around .">gradient(const GaussianBayesNet&amp;, const VectorValues&amp;)</a>. This specialized version is used with <a class="el" href="a00102.html">ISAM2</a>, where each clique stores its gradient contribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesTree</td><td>The Gaussian Bayes Tree $(R,d)$ </td></tr>
    <tr><td class="paramname">[output]</td><td>g A <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> to store the gradient, which must be preallocated, see allocateVectorValues </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient as a <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a612323e9be85348e9b49e17785742fb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::hasConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00065.html">FactorGraph</a>&lt; <a class="el" href="a00078.html">GaussianFactor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates whether linear factors have any constrained noise models. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any factor is constrained. </dd></dl>

</div>
</div>
<a class="anchor" id="afb77eefc25dea0fb3e0fcc8f246b617a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; double, Vector &gt; gtsam::house </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>house(x,j) computes HouseHolder vector v and scaling factor beta from x, such that the corresponding Householder reflection zeroes out all but x. </p>
<p>(j), j is base 0. Golub &amp; Van Loan p 210. </p>

</div>
</div>
<a class="anchor" id="a7baa2f3184a444adce108633c0265e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::householder </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Householder tranformation, zeros below diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>number of columns to zero out below diagonal </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing: in place !!! </dd></dl>

</div>
</div>
<a class="anchor" id="abdd1ab05e8ac90b340fbd8f3b322dc6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::householder_ </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_vectors</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imperative version of Householder QR factorization, Golub &amp; Van Loan p 224 version with Householder vectors below diagonal, as in GVL. </p>
<p>Householder tranformation, Householder vectors below diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>number of columns to zero out below diagonal </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">copy_vectors</td><td>- true to copy Householder vectors below diagonal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing: in place !!! </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc9a38f15c24872e82b504fa9761340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::inplace_QR </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QR factorization using Eigen's internal block QR algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the input matrix, and is the output </td></tr>
    <tr><td class="paramname">clear_below_diagonal</td><td>enables zeroing out below diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8583da4b37aefb1697375402a265c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::insertColumn </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts a column into a matrix IN PLACE NOTE: there is no size checking Alternate form allows for vectors smaller than the whole column to be inserted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to be modified in place </td></tr>
    <tr><td class="paramname">col</td><td>is the vector to be inserted </td></tr>
    <tr><td class="paramname">j</td><td>is the index to insert the column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b42c1bd6a8d1152ee1ef86b96526993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::insertSub </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>fullMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>subMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert a submatrix IN PLACE at a specified location in a larger matrix NOTE: there is no size checking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullMatrix</td><td>matrix to be updated </td></tr>
    <tr><td class="paramname">subMatrix</td><td>matrix to be inserted </td></tr>
    <tr><td class="paramname">i</td><td>is the row of the upper left corner insert location </td></tr>
    <tr><td class="paramname">j</td><td>is the column of the upper left corner insert location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a0cfd7908b06491df49b6a9c9186775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::linear_dependent </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether two vectors are linearly dependent </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a60d6f844b3fc9874c46f1a753aa03489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::LLt </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical Recipes in C wrappers create Numerical Recipes in C structure pointers are subtracted by one to provide base 1 access. </p>
<p>Calculate the LL^t decomposition of a S.P.D matrix. </p>

</div>
</div>
<a class="anchor" id="a1dcfc59dfe82c86e4f23381b4092acea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt;NonlinearFactorGraph::shared_ptr, <a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&gt; gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::string, boost::optional&lt; noiseModel::Diagonal::shared_ptr &gt; &gt;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO 2D Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset/model</td><td>pair as constructed by [dataset] </td></tr>
    <tr><td class="paramname">maxID</td><td>if non-zero cut out vertices &gt;= maxID </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73b0a64ce60fcad87492dfce610e3d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt;NonlinearFactorGraph::shared_ptr, <a class="el" href="a00202.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a>&gt; gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; gtsam::SharedDiagonal &gt;&#160;</td>
          <td class="paramname"><em>model</em> = <code>boost::optional&lt;&#160;noiseModel::Diagonal::shared_ptr&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO 2D Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
    <tr><td class="paramname">model</td><td>optional noise model to use instead of one specified by file </td></tr>
    <tr><td class="paramname">maxID</td><td>if non-zero cut out vertices &gt;= maxID </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e52ac8802179bab53e61d2411515e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::logDeterminant </td>
          <td>(</td>
          <td class="paramtype">const GaussianBayesTree &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the log determinant of a GassianBayesTree A GassianBayesTree is an upper triangular matrix and for an upper triangular matrix determinant is the product of the diagonal elements. </p>
<p>Instead of actually multiplying we add the logarithms of the diagonal elements because this is more numerically stable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bayesTree</td><td>The input GassianBayesTree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log determinant </dd></dl>

</div>
</div>
<a class="anchor" id="a75c80ae2fd169fcdd8708c37784a880a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::logmap_default </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log map centered at l0, s.t. </p>
<p>exp(l0,log(l0,lp)) = lp </p>

</div>
</div>
<a class="anchor" id="ab21cbc51fd8128a843739dbe5e0b2421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::max </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the max element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a) </dd></dl>

</div>
</div>
<a class="anchor" id="ae9a7dceb0a85c356062b55f6939b1419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> gtsam::mrsymbol </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol key from a character, label and index, i.e. </p>
<p>xA5. </p>

</div>
</div>
<a class="anchor" id="a37995b0d0610e5fb29c6bd0715151d67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char gtsam::mrsymbolChr </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the character portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a4adc1bb606fa4a14d5dbd246f95cecd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gtsam::mrsymbolIndex </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a4e4c133c4fd0d9d73593f601be2248a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char gtsam::mrsymbolLabel </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the label portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="abe111950f7be8c5e1e4e17d35f97fd04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::multiplyInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00062.html">Errors</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place version e &lt;- A*x that overwrites e. </p>

</div>
</div>
<a class="anchor" id="a798c18aa5033f3b3ab20bb954ed9fcaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::multiplyInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00079.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Errors::iterator &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place version e &lt;- A*x that takes an iterator. </p>

</div>
</div>
<a class="anchor" id="a84fe4789f88b33c6ab5119b1e2d007e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt;V, size_t&gt; gtsam::nonlinearConjugateGradient </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NonlinearOptimizerParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>gradientDescent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement the nonlinear conjugate gradient method using the Polak-Ribieve formula suggested in <a href="http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method">http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>. </p>
<p>The S (system) class requires three member functions: error(state), gradient(state) and advance(state, step-size, direction). The V class denotes the state or the solution.</p>
<p>The last parameter is a switch between gradient-descent and conjugate gradient </p>

</div>
</div>
<a class="anchor" id="aaa3ddc32a5a6b8eed2d5efe69d1cb171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::norm_2 </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates L2 norm for a vector modeled after boost.ublas for compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the L2 norm </dd></dl>

</div>
</div>
<a class="anchor" id="a168905f3fbaf00610d4dc486bcc4365b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative11 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of unary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>unary function yielding m-vector </td></tr>
    <tr><td class="paramname">x</td><td>n-dimensional value at which to evaluate h </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative Class Y is the output argument Class X is the input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing Both classes X,Y need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="aeaaad2ac19febd86f2afa7c6916659b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative21 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of binary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>binary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="ad054ef564f08a62522b456cf677502a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative22 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of binary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>binary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>n-dimensional second argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="af6cefcc2e690755b40d84f04beb123ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative31 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4fe49c0dea74639a95bfb58e21e663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative32 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="a5def64a08dde6bc660af18e22f69e901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative33 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 3 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="a11dc11c40862fe22c0ebab881edda95a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalHessian </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; double(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute numerical Hessian matrix. </p>
<p>Requires a single-argument Lie-&gt;scalar function. This is implemented simply as the derivative of the gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function taking a Lie object as input and returning a scalar </td></tr>
    <tr><td class="paramname">x</td><td>The center point for computing the Hessian </td></tr>
    <tr><td class="paramname">delta</td><td>The numerical derivative step size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n*n Hessian matrix computed via central differencing </dd></dl>

</div>
</div>
<a class="anchor" id="aa4782bb65cdbe1fdd391080d1754a20f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::ones </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create vector initialized to ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d85957bab2d18cf56ab9aaf95a106de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::istream &amp; gtsam::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>destinationMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix from an input stream, such as a file. </p>
<p>Entries can be either tab-, space-, or comma-separated, similar to the format read by the MATLAB dlmread command. </p>

</div>
</div>
<a class="anchor" id="a358cd7b51eb4d286b177a29a5df85d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::optimize </td>
          <td>(</td>
          <td class="paramtype">const DiscreteBayesNet &amp;&#160;</td>
          <td class="paramname"><em>bn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize function for back-substitution. </p>
<p>Solve the GaussianBayesNet, i.e.</p>
<p>return \( x = R^{-1}*d \), computed by back-substitution. </p>

</div>
</div>
<a class="anchor" id="a18b805fc8803b45fb43e5f8edbc3edd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::optimizeGradientSearch </td>
          <td>(</td>
          <td class="paramtype">const GaussianBayesTree &amp;&#160;</td>
          <td class="paramname"><em>bayesTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize along the gradient direction, with a closed-form computation to perform the line search. </p>
<p>The gradient is computed about \( \delta x=0 \).</p>
<p>This function returns \( \delta x \) that minimizes a reparametrized problem. The error function of a GaussianBayesNet is</p>
<p class="formulaDsp">
\[ f(\delta x) = \frac{1}{2} |R \delta x - d|^2 = \frac{1}{2}d^T d - d^T R \delta x + \frac{1}{2} \delta x^T R^T R \delta x \]
</p>
<p>with gradient and Hessian</p>
<p class="formulaDsp">
\[ g(\delta x) = R^T(R\delta x - d), \qquad G(\delta x) = R^T R. \]
</p>
<p>This function performs the line search in the direction of the gradient evaluated at \( g = g(\delta x = 0) \) with step size \( \alpha \) that minimizes \( f(\delta x = \alpha g) \):</p>
<p class="formulaDsp">
\[ f(\alpha) = \frac{1}{2} d^T d + g^T \delta x + \frac{1}{2} \alpha^2 g^T G g \]
</p>
<p>Optimizing by setting the derivative to zero yields \( \hat \alpha = (-g^T g) / (g^T G g) \). For efficiency, this function evaluates the denominator without computing the Hessian \( G \), returning</p>
<p class="formulaDsp">
\[ \delta x = \hat\alpha g = \frac{-g^T g}{(R g)^T(R g)} \]
</p>
 
</div>
</div>
<a class="anchor" id="a07a95b31369c4b864a852d1f1db11875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::optimizeGradientSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize along the gradient direction, with a closed-form computation to perform the line search. </p>
<p>The gradient is computed about \( \delta x=0 \).</p>
<p>This function returns \( \delta x \) that minimizes a reparametrized problem. The error function of a GaussianBayesNet is</p>
<p class="formulaDsp">
\[ f(\delta x) = \frac{1}{2} |R \delta x - d|^2 = \frac{1}{2}d^T d - d^T R \delta x + \frac{1}{2} \delta x^T R^T R \delta x \]
</p>
<p>with gradient and Hessian</p>
<p class="formulaDsp">
\[ g(\delta x) = R^T(R\delta x - d), \qquad G(\delta x) = R^T R. \]
</p>
<p>This function performs the line search in the direction of the gradient evaluated at \( g = g(\delta x = 0) \) with step size \( \alpha \) that minimizes \( f(\delta x = \alpha g) \):</p>
<p class="formulaDsp">
\[ f(\alpha) = \frac{1}{2} d^T d + g^T \delta x + \frac{1}{2} \alpha^2 g^T G g \]
</p>
<p>Optimizing by setting the derivative to zero yields \( \hat \alpha = (-g^T g) / (g^T G g) \). For efficiency, this function evaluates the denominator without computing the Hessian \( G \), returning</p>
<p class="formulaDsp">
\[ \delta x = \hat\alpha g = \frac{-g^T g}{(R g)^T(R g)} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bn</td><td>The GaussianBayesNet on which to perform this computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting \( \delta x \) as described above </dd></dl>

</div>
</div>
<a class="anchor" id="a87e0060b201a8f1aeb004c8347b34023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00210.html">VectorValues</a> gtsam::optimizeGradientSearch </td>
          <td>(</td>
          <td class="paramtype">const ISAM2 &amp;&#160;</td>
          <td class="paramname"><em>isam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize along the gradient direction, with a closed-form computation to perform the line search. </p>
<p>The gradient is computed about \( \delta x=0 \).</p>
<p>This function returns \( \delta x \) that minimizes a reparametrized problem. The error function of a GaussianBayesNet is</p>
<p class="formulaDsp">
\[ f(\delta x) = \frac{1}{2} |R \delta x - d|^2 = \frac{1}{2}d^T d - d^T R \delta x + \frac{1}{2} \delta x^T R^T R \delta x \]
</p>
<p>with gradient and Hessian</p>
<p class="formulaDsp">
\[ g(\delta x) = R^T(R\delta x - d), \qquad G(\delta x) = R^T R. \]
</p>
<p>This function performs the line search in the direction of the gradient evaluated at \( g = g(\delta x = 0) \) with step size \( \alpha \) that minimizes \( f(\delta x = \alpha g) \):</p>
<p class="formulaDsp">
\[ f(\alpha) = \frac{1}{2} d^T d + g^T \delta x + \frac{1}{2} \alpha^2 g^T G g \]
</p>
<p>Optimizing by setting the derivative to zero yields \( \hat \alpha = (-g^T g) / (g^T G g) \). For efficiency, this function evaluates the denominator without computing the Hessian \( G \), returning</p>
<p class="formulaDsp">
\[ \delta x = \hat\alpha g = \frac{-g^T g}{(R g)^T(R g)} \]
</p>
 
</div>
</div>
<a class="anchor" id="a38cc916d8f1f9d6c3e321ec12b8197a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::optimizeGradientSearchInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place version of <a class="el" href="a00243.html#a07a95b31369c4b864a852d1f1db11875" title="Optimize along the gradient direction, with a closed-form computation to perform the line search...">optimizeGradientSearch(const GaussianBayesNet&amp;)</a> requiring pre-allocated <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a> <code>grad</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bn</td><td>The GaussianBayesNet on which to perform this computation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad</td><td>The resulting \( \delta x \) as described in <a class="el" href="a00243.html#a07a95b31369c4b864a852d1f1db11875" title="Optimize along the gradient direction, with a closed-form computation to perform the line search...">optimizeGradientSearch(const GaussianBayesNet&amp;)</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bf6c5f3d6f9d0d8edfed780e74a6b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::optimizeInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00243.html#a10d4ade73a7e1d467c65d858dff18016">GaussianBayesNet</a> &amp;&#160;</td>
          <td class="paramname"><em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00210.html">VectorValues</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the GaussianBayesNet, i.e. </p>
<p>return \( x = R^{-1}*d \), computed by back-substitution, writes the solution \( x \) into a pre-allocated <a class="el" href="a00210.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a>. You can use <a class="el" href="a00243.html#a86fbbe1d4059980af59689064b2602f4" title="Allocate a VectorValues for the variables in a BayesNet.">allocateVectorValues(const GaussianBayesNet&amp;)</a> allocate it. See also <a class="el" href="a00243.html#a358cd7b51eb4d286b177a29a5df85d07" title="Optimize function for back-substitution.">optimize(const GaussianBayesNet&amp;)</a>, which does not require pre-allocation. </p>
<p>solve each node in turn in topological sort order (parents first) </p>

</div>
</div>
<a class="anchor" id="a49dde188b771621fb28d8d8db471df96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CLIQUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int gtsam::optimizeWildfire </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; CLIQUE &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorValues &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize the <a class="el" href="a00010.html">BayesTree</a>, starting from the root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replaced</td><td>Needs to contain all variables that are contained in the top of the Bayes tree that has been redone. </td></tr>
    <tr><td class="paramname">delta</td><td>The current solution, an offset from the linearization point. </td></tr>
    <tr><td class="paramname">threshold</td><td>The maximum change against the PREVIOUS delta for non-replaced variables that can be ignored, ie. the old delta entry is kept and recursive backsubstitution might eventually stop if none of the changed variables are contained in the subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of variables that were solved for </dd></dl>

</div>
</div>
<a class="anchor" id="ae67d0d86c4e55b175859967a70b36983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class V , class KEY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; G, V, std::map&lt; KEY, V &gt; &gt; gtsam::predecessorMap2Graph </td>
          <td>(</td>
          <td class="paramtype">const PredecessorMap&lt; KEY &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build takes a predecessor map, and builds a directed graph corresponding to the tree. </p>
<p>G = Graph type V = Vertex type </p>

</div>
</div>
<a class="anchor" id="ae32c295e2c40c1e85f146a8a6266eaa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Matrix, Matrix &gt; gtsam::qr </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Householder QR factorization, Golub &amp; Van Loan p 224, explicit version. </p>
<p>QR factorization, inefficient, best use imperative householder below m*n matrix -&gt; m*m Q, m*n R.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;Q,R&gt; rotation matrix Q, upper triangular R </dd></dl>

</div>
</div>
<a class="anchor" id="a0853fc18973e23bb407825df52c95515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::reciprocal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise reciprocal of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[1/a(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="af50343afb840c2e690b5b86b69ab691a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::repeat </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create vector initialized to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">value</td><td>is a constant value to insert into the vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2754f325c8600303d627d9e8cf1f9949"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MATRIX::ConstRowXpr gtsam::row </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a row view from a matrix that avoids a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to extract row from </td></tr>
    <tr><td class="paramname">j</td><td>index of the row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const view of the matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a9d06ed5dc919a7d92968509198d40361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; Matrix3, Vector3 &gt; gtsam::RQ </td>
          <td>(</td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R and 3 rotation angles corresponding to the rotation matrix Q=Qz'*Qy'*Qx' such that A = R*Q = R*Qz'*Qy'*Qx'. </p>
<p>When A is a rotation matrix, R will be the identity and Q is a yaw-pitch-roll decomposition of A. The implementation uses Givens rotations and is based on Hartley-Zisserman. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>3 by 3 matrix A=RQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an upper triangular matrix R </dd>
<dd>
a vector [thetax, thetay, thetaz] in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="ad371582718b5e685ace31c176f2a9abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::scal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BLAS Level 1 scal: x &lt;- alpha*x. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00481.html#_deprecated000002">Deprecated:</a></b></dt><dd>: use operators instead </dd></dl>

</div>
</div>
<a class="anchor" id="a60bc5c23cdae085b88d12056c7411463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix3 gtsam::skewSymmetric </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>skew symmetric matrix returns this: 0 -wz wy wz 0 -wx -wy wx 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wx</td><td>3 dimensional vector </td></tr>
    <tr><td class="paramname">wy</td><td></td></tr>
    <tr><td class="paramname">wz</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 3*3 skew symmetric matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a5c82884a356ddd09229a5283aed04df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::stack </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrMatrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a matrix by stacking other matrices Given a set of matrices: A1, A2, A3... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>pointers to matrices to be stacked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined matrix [A1; A2; A3] </dd></dl>

</div>
</div>
<a class="anchor" id="aed4b2ca704ddd6530ea70122f883ac88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::steepestDescent </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConjugateGradientParameters &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience calls using matrices, will create <a class="el" href="a00194.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class internally: </p>
<p>Method of steepest gradients, Matrix version </p>

</div>
</div>
<a class="anchor" id="aed6673ca73bb7ab59f46f08e3a5cc284"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt;const MATRIX&gt; gtsam::sub </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract submatrix, slice semantics, i.e. </p>
<p>range = [i1,i2[ excluding i2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">i1</td><td>first row index </td></tr>
    <tr><td class="paramname">i2</td><td>last row index + 1 </td></tr>
    <tr><td class="paramname">j1</td><td>first col index </td></tr>
    <tr><td class="paramname">j2</td><td>last col index + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>submatrix A(i1:i2-1,j1:j2-1) </dd></dl>

</div>
</div>
<a class="anchor" id="af694dd7a0838c24e3484068cc1657f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT ConstSubVector gtsam::sub </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract subvector, slice semantics, i.e. </p>
<p>range = [i1,i2[ excluding i2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector </td></tr>
    <tr><td class="paramname">i1</td><td>first row index </td></tr>
    <tr><td class="paramname">i2</td><td>last row index + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subvector v(i1:i2) </dd></dl>

</div>
</div>
<a class="anchor" id="abe442f79470225ffccfc8bc5ce46a87a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::subInsert </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>fullVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>subVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a subvector into a vector IN PLACE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullVector</td><td>is the vector to be changed </td></tr>
    <tr><td class="paramname">subVector</td><td>is the vector to insert </td></tr>
    <tr><td class="paramname">i</td><td>is the index where the subvector should be inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a316a9f631367da3caae876b41b345867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::sum </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sum vector elements </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum_i a(i) </dd></dl>

</div>
</div>
<a class="anchor" id="abc653ffcec5154f355877f6a802b8b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00079.html">GaussianFactorGraph</a>,<a class="el" href="a00151.html">Ordering</a>&gt; gtsam::summarize </td>
          <td>(</td>
          <td class="paramtype">const NonlinearFactorGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Values &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeySet &amp;&#160;</td>
          <td class="paramname"><em>saved_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SummarizationMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PARTIAL_QR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Summarization function to remove a subset of variables from a system with the sequential solver. </p>
<p>This does not require that the system be fully constrained.</p>
<p>Requirement: set of keys in the graph should match the set of keys in the values structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A full nonlinear graph </td></tr>
    <tr><td class="paramname">values</td><td>The chosen linearization point </td></tr>
    <tr><td class="paramname">saved_keys</td><td>is the set of keys for variables that should remain </td></tr>
    <tr><td class="paramname">mode</td><td>controls what elimination technique and requirements to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the remaining graph and the ordering used for linearization </dd></dl>

</div>
</div>
<a class="anchor" id="afbdaa652f50405a7ae95d28b55aeb55b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00145.html">NonlinearFactorGraph</a> gtsam::summarizeAsNonlinearContainer </td>
          <td>(</td>
          <td class="paramtype">const NonlinearFactorGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Values &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeySet &amp;&#160;</td>
          <td class="paramname"><em>saved_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SummarizationMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PARTIAL_QR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the same summarization technique used in <a class="el" href="a00243.html#abc653ffcec5154f355877f6a802b8b7e" title="Summarization function to remove a subset of variables from a system with the sequential solver...">summarize()</a>, but returns the result as a <a class="el" href="a00145.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> comprised of LinearContainerFactors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A full nonlinear graph </td></tr>
    <tr><td class="paramname">values</td><td>The chosen linearization point </td></tr>
    <tr><td class="paramname">saved_keys</td><td>is the set of keys for variables that should remain </td></tr>
    <tr><td class="paramname">useQR</td><td>uses QR as the elimination algorithm if true, Cholesky otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="a00145.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> with linear factors </dd></dl>

</div>
</div>
<a class="anchor" id="a8d7e46204d953f64a39445599dbd7eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::svd </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SVD computes economy SVD A=U*S*V'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>an m*n matrix </td></tr>
    <tr><td class="paramname">U</td><td>output argument: rotation matrix </td></tr>
    <tr><td class="paramname">S</td><td>output argument: sorted vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>output argument: rotation matrix if m &gt; n then U*S*V' = (m*n)*(n*n)*(n*n) if m &lt; n then U*S*V' = (m*m)*(m*m)*(m*n) Careful! The dimensions above reflect V', not V, which is n*m if m&lt;n. U is a basis in R^m, V is a basis in R^n You can just pass empty matrices U,V, and vector S, they will be re-allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cd266db68d8146af3b9b1630d4b700b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00243.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> gtsam::symbol </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol key from a character and index, i.e. </p>
<p>x5. </p>

</div>
</div>
<a class="anchor" id="a9ca9499e881d22361b4833c2854d941f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char gtsam::symbolChr </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the character portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a901c06d89d5c4ba46d926a86b307f271"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gtsam::symbolIndex </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a80d640f59e5d39a1165069a3841cc5d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">P gtsam::transform_point </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; Matrix &amp; &gt;&#160;</td>
          <td class="paramname"><em>Dtrans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; Matrix &amp; &gt;&#160;</td>
          <td class="paramname"><em>Dglobal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform function that must be specialized specific domains. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is a Transform type </td></tr>
    <tr><td class="paramname">P</td><td>is a point type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24d3ad0252f91f0ec301593c45cf5af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::vector_scale_inplace </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inf_mask</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scales a matrix row or column by the values in a vector Arguments (Matrix, Vector) scales the columns, (Vector, Matrix) scales the rows </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inf_mask</td><td>when true, will not scale with a NaN or inf value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefb606eb24889c0f418acf1515a2c723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix <a class="el" href="a00243.html#afe28b7f8e3592fb9f5cf9ebae09497ba">gtsam::wedge</a>&lt; <a class="el" href="a00160.html">Pose3</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>xi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wedge for <a class="el" href="a00160.html">Pose3</a>: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xi</td><td>6-dim twist (omega,v) where omega = 3D angular velocity v = 3D velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xihat, 4*4 element of Lie algebra that can be exponentiated </dd></dl>

</div>
</div>
<a class="anchor" id="a60019a03f26b92c6b2a08e43d153d4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::list&lt; boost::tuple&lt; Vector, double, double &gt; &gt; gtsam::weighted_eliminate </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>sigmas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imperative algorithm for in-place full elimination with weights and constraint handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix to eliminate </td></tr>
    <tr><td class="paramname">b</td><td>is the rhs </td></tr>
    <tr><td class="paramname">sigmas</td><td>is a vector of the measurement standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of r vectors, d and sigma </dd></dl>

</div>
</div>
<a class="anchor" id="aca1c56d11a05464a7a5458dc32ccc777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Vector, double &gt; gtsam::weightedPseudoinverse </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighted Householder solution vector, a.k.a., the pseudoinverse of the column NOTE: if any sigmas are zero (indicating a constraint) the pseudoinverse will be a selection vector, and the variance will be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the first column of the matrix to solve </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of weights/precisions where w=1/(s*s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the pseudoinverse of v and the associated precision/weight </dd></dl>

</div>
</div>
<a class="anchor" id="a067f9515f6cd64987f4604127398fb9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::zero </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create zero vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57edf6ed7312f63d35f73233665c334d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::zeroBelowDiagonal </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zeros all of the elements below the diagonal of a matrix, in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix, to be modified in place </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns to zero, use zero for all columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33240affd7dc54b7a85c6f3136853f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::zeros </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an zeros matrix, with matlab-like syntax. </p>
<p>Note: if assigning a block (created from an Eigen block() function) of a matrix to zeros, don't use this function, instead use ".setZero(m,n)" to avoid an Eigen error. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00243.html">gtsam</a></li>
    <li class="footer">Generated on Tue Aug 13 2013 16:47:11 for gtsam by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
